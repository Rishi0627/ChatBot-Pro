"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/react/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/ai/react/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   experimental_useObject: () => (/* binding */ experimental_useObject),\n/* harmony export */   useAssistant: () => (/* binding */ useAssistant),\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/react */ \"(ssr)/./node_modules/@ai-sdk/react/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ experimental_useObject,useAssistant,useChat,useCompletion auto */ // react/index.ts\n\nvar useChat = _ai_sdk_react__WEBPACK_IMPORTED_MODULE_0__.useChat;\nvar useCompletion = _ai_sdk_react__WEBPACK_IMPORTED_MODULE_0__.useCompletion;\nvar useAssistant = _ai_sdk_react__WEBPACK_IMPORTED_MODULE_0__.useAssistant;\nvar experimental_useObject = _ai_sdk_react__WEBPACK_IMPORTED_MODULE_0__.experimental_useObject;\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBS087QUFFQSxJQUFNQSxVQUFVQyxrREFBWUE7QUFDNUIsSUFBTUMsZ0JBQWdCQyx3REFBa0JBO0FBQ3hDLElBQU1DLGVBQWVDLHVEQUFpQkE7QUFDdEMsSUFBTUMseUJBQXlCQyxpRUFBMkJBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdC1haS8uLi9pbmRleC50cz83MzEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIHVzZUNoYXQgYXMgdXNlQ2hhdFJlYWN0LFxuICB1c2VDb21wbGV0aW9uIGFzIHVzZUNvbXBsZXRpb25SZWFjdCxcbiAgdXNlQXNzaXN0YW50IGFzIHVzZUFzc2lzdGFudFJlYWN0LFxuICBleHBlcmltZW50YWxfdXNlT2JqZWN0IGFzIGV4cGVyaW1lbnRhbF91c2VPYmplY3RSZWFjdCxcbn0gZnJvbSAnQGFpLXNkay9yZWFjdCc7XG5cbmV4cG9ydCBjb25zdCB1c2VDaGF0ID0gdXNlQ2hhdFJlYWN0O1xuZXhwb3J0IGNvbnN0IHVzZUNvbXBsZXRpb24gPSB1c2VDb21wbGV0aW9uUmVhY3Q7XG5leHBvcnQgY29uc3QgdXNlQXNzaXN0YW50ID0gdXNlQXNzaXN0YW50UmVhY3Q7XG5leHBvcnQgY29uc3QgZXhwZXJpbWVudGFsX3VzZU9iamVjdCA9IGV4cGVyaW1lbnRhbF91c2VPYmplY3RSZWFjdDtcbmV4cG9ydCB0eXBlIHtcbiAgQ3JlYXRlTWVzc2FnZSxcbiAgTWVzc2FnZSxcbiAgVXNlQ2hhdE9wdGlvbnMsXG4gIFVzZUNoYXRIZWxwZXJzLFxufSBmcm9tICdAYWktc2RrL3JlYWN0JztcbiJdLCJuYW1lcyI6WyJ1c2VDaGF0IiwidXNlQ2hhdFJlYWN0IiwidXNlQ29tcGxldGlvbiIsInVzZUNvbXBsZXRpb25SZWFjdCIsInVzZUFzc2lzdGFudCIsInVzZUFzc2lzdGFudFJlYWN0IiwiZXhwZXJpbWVudGFsX3VzZU9iamVjdCIsImV4cGVyaW1lbnRhbF91c2VPYmplY3RSZWFjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/react/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/dist/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/ai/dist/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIStream: () => (/* binding */ AIStream),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError),\n/* harmony export */   AWSBedrockAnthropicMessagesStream: () => (/* binding */ AWSBedrockAnthropicMessagesStream),\n/* harmony export */   AWSBedrockAnthropicStream: () => (/* binding */ AWSBedrockAnthropicStream),\n/* harmony export */   AWSBedrockCohereStream: () => (/* binding */ AWSBedrockCohereStream),\n/* harmony export */   AWSBedrockLlama2Stream: () => (/* binding */ AWSBedrockLlama2Stream),\n/* harmony export */   AWSBedrockStream: () => (/* binding */ AWSBedrockStream),\n/* harmony export */   AnthropicStream: () => (/* binding */ AnthropicStream),\n/* harmony export */   AssistantResponse: () => (/* binding */ AssistantResponse),\n/* harmony export */   CohereStream: () => (/* binding */ CohereStream),\n/* harmony export */   EmbedManyResult: () => (/* binding */ EmbedManyResult),\n/* harmony export */   EmbedResult: () => (/* binding */ EmbedResult),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError),\n/* harmony export */   GenerateObjectResult: () => (/* binding */ GenerateObjectResult),\n/* harmony export */   GenerateTextResult: () => (/* binding */ GenerateTextResult),\n/* harmony export */   GoogleGenerativeAIStream: () => (/* binding */ GoogleGenerativeAIStream),\n/* harmony export */   HuggingFaceStream: () => (/* binding */ HuggingFaceStream),\n/* harmony export */   InkeepStream: () => (/* binding */ InkeepStream),\n/* harmony export */   InvalidArgumentError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidDataContentError),\n/* harmony export */   InvalidMessageRoleError: () => (/* binding */ InvalidMessageRoleError),\n/* harmony export */   InvalidModelIdError: () => (/* binding */ InvalidModelIdError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidResponseDataError),\n/* harmony export */   InvalidToolArgumentsError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidToolArgumentsError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError),\n/* harmony export */   LangChainAdapter: () => (/* binding */ langchain_adapter_exports),\n/* harmony export */   LangChainStream: () => (/* binding */ LangChainStream),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError),\n/* harmony export */   MistralStream: () => (/* binding */ MistralStream),\n/* harmony export */   NoObjectGeneratedError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoObjectGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* binding */ NoSuchModelError),\n/* harmony export */   NoSuchProviderError: () => (/* binding */ NoSuchProviderError),\n/* harmony export */   NoSuchToolError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchToolError),\n/* harmony export */   OpenAIStream: () => (/* binding */ OpenAIStream),\n/* harmony export */   ReplicateStream: () => (/* binding */ ReplicateStream),\n/* harmony export */   RetryError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.RetryError),\n/* harmony export */   StreamData: () => (/* binding */ StreamData),\n/* harmony export */   StreamObjectResult: () => (/* binding */ StreamObjectResult),\n/* harmony export */   StreamTextResult: () => (/* binding */ StreamTextResult),\n/* harmony export */   StreamingTextResponse: () => (/* binding */ StreamingTextResponse),\n/* harmony export */   ToolCallParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.ToolCallParseError),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError),\n/* harmony export */   UnsupportedJSONSchemaError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedJSONSchemaError),\n/* harmony export */   convertDataContentToBase64String: () => (/* binding */ convertDataContentToBase64String),\n/* harmony export */   convertDataContentToUint8Array: () => (/* binding */ convertDataContentToUint8Array),\n/* harmony export */   convertToCoreMessages: () => (/* binding */ convertToCoreMessages),\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   createCallbacksTransformer: () => (/* binding */ createCallbacksTransformer),\n/* harmony export */   createEventStreamTransformer: () => (/* binding */ createEventStreamTransformer),\n/* harmony export */   createStreamDataTransformer: () => (/* binding */ createStreamDataTransformer),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   embedMany: () => (/* binding */ embedMany),\n/* harmony export */   experimental_AssistantResponse: () => (/* binding */ experimental_AssistantResponse),\n/* harmony export */   experimental_StreamData: () => (/* binding */ experimental_StreamData),\n/* harmony export */   experimental_createModelRegistry: () => (/* binding */ experimental_createModelRegistry),\n/* harmony export */   experimental_createProviderRegistry: () => (/* binding */ experimental_createProviderRegistry),\n/* harmony export */   experimental_generateObject: () => (/* binding */ experimental_generateObject),\n/* harmony export */   experimental_generateText: () => (/* binding */ experimental_generateText),\n/* harmony export */   experimental_streamObject: () => (/* binding */ experimental_streamObject),\n/* harmony export */   experimental_streamText: () => (/* binding */ experimental_streamText),\n/* harmony export */   formatStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart),\n/* harmony export */   generateId: () => (/* binding */ generateId2),\n/* harmony export */   generateObject: () => (/* binding */ generateObject),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   parseComplexResponse: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.parseComplexResponse),\n/* harmony export */   parseStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.parseStreamPart),\n/* harmony export */   readDataStream: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.readDataStream),\n/* harmony export */   readableFromAsyncIterable: () => (/* binding */ readableFromAsyncIterable),\n/* harmony export */   streamObject: () => (/* binding */ streamObject),\n/* harmony export */   streamText: () => (/* binding */ streamText),\n/* harmony export */   streamToResponse: () => (/* binding */ streamToResponse),\n/* harmony export */   tool: () => (/* binding */ tool),\n/* harmony export */   trimStartOfStreamHelper: () => (/* binding */ trimStartOfStreamHelper)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(rsc)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/eventsource-parser/dist/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// streams/index.ts\n\n\n\n// core/util/retry-with-exponential-backoff.ts\n\n\n\n// core/util/delay.ts\nasync function delay(delayInMs) {\n  return new Promise((resolve) => setTimeout(resolve, delayInMs));\n}\n\n// core/util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({\n  maxRetries = 2,\n  initialDelayInMs = 2e3,\n  backoffFactor = 2\n} = {}) => async (f) => _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs: initialDelayInMs,\n  backoffFactor\n});\nasync function _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs,\n  backoffFactor\n}, errors = []) {\n  try {\n    return await f();\n  } catch (error) {\n    if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.isAbortError)(error)) {\n      throw error;\n    }\n    if (maxRetries === 0) {\n      throw error;\n    }\n    const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n    if (tryNumber > maxRetries) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: \"maxRetriesExceeded\",\n        errors: newErrors\n      });\n    }\n    if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n      await delay(delayInMs);\n      return _retryWithExponentialBackoff(\n        f,\n        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },\n        newErrors\n      );\n    }\n    if (tryNumber === 1) {\n      throw error;\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: \"errorNotRetryable\",\n      errors: newErrors\n    });\n  }\n}\n\n// core/embed/embed.ts\nasync function embed({\n  model,\n  value,\n  maxRetries,\n  abortSignal,\n  headers\n}) {\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const modelResponse = await retry(\n    () => model.doEmbed({ values: [value], abortSignal, headers })\n  );\n  return new EmbedResult({\n    value,\n    embedding: modelResponse.embeddings[0],\n    rawResponse: modelResponse.rawResponse\n  });\n}\nvar EmbedResult = class {\n  constructor(options) {\n    this.value = options.value;\n    this.embedding = options.embedding;\n    this.rawResponse = options.rawResponse;\n  }\n};\n\n// core/util/split-array.ts\nfunction splitArray(array, chunkSize) {\n  if (chunkSize <= 0) {\n    throw new Error(\"chunkSize must be greater than 0\");\n  }\n  const result = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n  return result;\n}\n\n// core/embed/embed-many.ts\nasync function embedMany({\n  model,\n  values,\n  maxRetries,\n  abortSignal,\n  headers\n}) {\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const maxEmbeddingsPerCall = model.maxEmbeddingsPerCall;\n  if (maxEmbeddingsPerCall == null) {\n    const modelResponse = await retry(\n      () => model.doEmbed({ values, abortSignal, headers })\n    );\n    return new EmbedManyResult({\n      values,\n      embeddings: modelResponse.embeddings\n    });\n  }\n  const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n  const embeddings = [];\n  for (const chunk of valueChunks) {\n    const modelResponse = await retry(\n      () => model.doEmbed({ values: chunk, abortSignal, headers })\n    );\n    embeddings.push(...modelResponse.embeddings);\n  }\n  return new EmbedManyResult({ values, embeddings });\n}\nvar EmbedManyResult = class {\n  constructor(options) {\n    this.values = options.values;\n    this.embeddings = options.embeddings;\n  }\n};\n\n// core/generate-object/generate-object.ts\n\n\n\n// core/generate-text/token-usage.ts\nfunction calculateTokenUsage(usage) {\n  return {\n    promptTokens: usage.promptTokens,\n    completionTokens: usage.completionTokens,\n    totalTokens: usage.promptTokens + usage.completionTokens\n  };\n}\n\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n  { mimeType: \"image/gif\", bytes: [71, 73, 70] },\n  { mimeType: \"image/png\", bytes: [137, 80, 78, 71] },\n  { mimeType: \"image/jpeg\", bytes: [255, 216] },\n  { mimeType: \"image/webp\", bytes: [82, 73, 70, 70] }\n];\nfunction detectImageMimeType(image) {\n  for (const { bytes, mimeType } of mimeTypeSignatures) {\n    if (image.length >= bytes.length && bytes.every((byte, index) => image[index] === byte)) {\n      return mimeType;\n    }\n  }\n  return void 0;\n}\n\n// core/prompt/data-content.ts\n\n\nfunction convertDataContentToBase64String(content) {\n  if (typeof content === \"string\") {\n    return content;\n  }\n  if (content instanceof ArrayBuffer) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.convertUint8ArrayToBase64)(new Uint8Array(content));\n  }\n  return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n  if (typeof content === \"string\") {\n    try {\n      return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.convertBase64ToUint8Array)(content);\n    } catch (error) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidDataContentError({\n        message: \"Invalid data content. Content string is not a base64-encoded image.\",\n        content,\n        cause: error\n      });\n    }\n  }\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n  throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidDataContentError({ content });\n}\n\n// core/prompt/invalid-message-role-error.ts\nvar InvalidMessageRoleError = class extends Error {\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`\n  }) {\n    super(message);\n    this.name = \"AI_InvalidMessageRoleError\";\n    this.role = role;\n  }\n  static isInvalidMessageRoleError(error) {\n    return error instanceof Error && error.name === \"AI_InvalidMessageRoleError\" && typeof error.role === \"string\";\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      role: this.role\n    };\n  }\n};\n\n// core/prompt/convert-to-language-model-prompt.ts\n\nfunction convertToLanguageModelPrompt(prompt) {\n  const languageModelMessages = [];\n  if (prompt.system != null) {\n    languageModelMessages.push({ role: \"system\", content: prompt.system });\n  }\n  const promptType = prompt.type;\n  switch (promptType) {\n    case \"prompt\": {\n      languageModelMessages.push({\n        role: \"user\",\n        content: [{ type: \"text\", text: prompt.prompt }]\n      });\n      break;\n    }\n    case \"messages\": {\n      languageModelMessages.push(\n        ...prompt.messages.map(convertToLanguageModelMessage)\n      );\n      break;\n    }\n    default: {\n      const _exhaustiveCheck = promptType;\n      throw new Error(`Unsupported prompt type: ${_exhaustiveCheck}`);\n    }\n  }\n  return languageModelMessages;\n}\nfunction convertToLanguageModelMessage(message) {\n  const role = message.role;\n  switch (role) {\n    case \"system\": {\n      return { role: \"system\", content: message.content };\n    }\n    case \"user\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"user\",\n          content: [{ type: \"text\", text: message.content }]\n        };\n      }\n      return {\n        role: \"user\",\n        content: message.content.map(\n          (part) => {\n            var _a;\n            switch (part.type) {\n              case \"text\": {\n                return part;\n              }\n              case \"image\": {\n                if (part.image instanceof URL) {\n                  return {\n                    type: \"image\",\n                    image: part.image,\n                    mimeType: part.mimeType\n                  };\n                }\n                if (typeof part.image === \"string\") {\n                  try {\n                    const url = new URL(part.image);\n                    switch (url.protocol) {\n                      case \"http:\":\n                      case \"https:\": {\n                        return {\n                          type: \"image\",\n                          image: url,\n                          mimeType: part.mimeType\n                        };\n                      }\n                      case \"data:\": {\n                        try {\n                          const [header, base64Content] = part.image.split(\",\");\n                          const mimeType = header.split(\";\")[0].split(\":\")[1];\n                          if (mimeType == null || base64Content == null) {\n                            throw new Error(\"Invalid data URL format\");\n                          }\n                          return {\n                            type: \"image\",\n                            image: convertDataContentToUint8Array(base64Content),\n                            mimeType\n                          };\n                        } catch (error) {\n                          throw new Error(\n                            `Error processing data URL: ${(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(\n                              message\n                            )}`\n                          );\n                        }\n                      }\n                      default: {\n                        throw new Error(\n                          `Unsupported URL protocol: ${url.protocol}`\n                        );\n                      }\n                    }\n                  } catch (_ignored) {\n                  }\n                }\n                const imageUint8 = convertDataContentToUint8Array(part.image);\n                return {\n                  type: \"image\",\n                  image: imageUint8,\n                  mimeType: (_a = part.mimeType) != null ? _a : detectImageMimeType(imageUint8)\n                };\n              }\n            }\n          }\n        )\n      };\n    }\n    case \"assistant\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"assistant\",\n          content: [{ type: \"text\", text: message.content }]\n        };\n      }\n      return {\n        role: \"assistant\",\n        content: message.content.filter(\n          // remove empty text parts:\n          (part) => part.type !== \"text\" || part.text !== \"\"\n        )\n      };\n    }\n    case \"tool\": {\n      return message;\n    }\n    default: {\n      const _exhaustiveCheck = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\n\n// core/prompt/get-validated-prompt.ts\n\nfunction getValidatedPrompt(prompt) {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n      prompt,\n      message: \"prompt and messages cannot be defined at the same time\"\n    });\n  }\n  return prompt.prompt != null ? {\n    type: \"prompt\",\n    prompt: prompt.prompt,\n    messages: void 0,\n    system: prompt.system\n  } : {\n    type: \"messages\",\n    prompt: void 0,\n    messages: prompt.messages,\n    // only possible case bc of checks above\n    system: prompt.system\n  };\n}\n\n// core/prompt/prepare-call-settings.ts\n\nfunction prepareCallSettings({\n  maxTokens,\n  temperature,\n  topP,\n  presencePenalty,\n  frequencyPenalty,\n  seed,\n  maxRetries\n}) {\n  if (maxTokens != null) {\n    if (!Number.isInteger(maxTokens)) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"maxTokens\",\n        value: maxTokens,\n        message: \"maxTokens must be an integer\"\n      });\n    }\n    if (maxTokens < 1) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"maxTokens\",\n        value: maxTokens,\n        message: \"maxTokens must be >= 1\"\n      });\n    }\n  }\n  if (temperature != null) {\n    if (typeof temperature !== \"number\") {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"temperature\",\n        value: temperature,\n        message: \"temperature must be a number\"\n      });\n    }\n  }\n  if (topP != null) {\n    if (typeof topP !== \"number\") {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"topP\",\n        value: topP,\n        message: \"topP must be a number\"\n      });\n    }\n  }\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== \"number\") {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"presencePenalty\",\n        value: presencePenalty,\n        message: \"presencePenalty must be a number\"\n      });\n    }\n  }\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== \"number\") {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"frequencyPenalty\",\n        value: frequencyPenalty,\n        message: \"frequencyPenalty must be a number\"\n      });\n    }\n  }\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"seed\",\n        value: seed,\n        message: \"seed must be an integer\"\n      });\n    }\n  }\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be an integer\"\n      });\n    }\n    if (maxRetries < 0) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be >= 0\"\n      });\n    }\n  }\n  return {\n    maxTokens,\n    temperature: temperature != null ? temperature : 0,\n    topP,\n    presencePenalty,\n    frequencyPenalty,\n    seed,\n    maxRetries: maxRetries != null ? maxRetries : 2\n  };\n}\n\n// core/util/convert-zod-to-json-schema.ts\n\nfunction convertZodToJSONSchema(zodSchema) {\n  return (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(zodSchema);\n}\n\n// core/generate-object/inject-json-schema-into-system.ts\nvar DEFAULT_SCHEMA_PREFIX = \"JSON schema:\";\nvar DEFAULT_SCHEMA_SUFFIX = \"You MUST answer with a JSON object that matches the JSON schema above.\";\nfunction injectJsonSchemaIntoSystem({\n  system,\n  schema,\n  schemaPrefix = DEFAULT_SCHEMA_PREFIX,\n  schemaSuffix = DEFAULT_SCHEMA_SUFFIX\n}) {\n  return [\n    system,\n    system != null ? \"\" : null,\n    // add a newline if system is not null\n    schemaPrefix,\n    JSON.stringify(schema),\n    schemaSuffix\n  ].filter((line) => line != null).join(\"\\n\");\n}\n\n// core/util/prepare-response-headers.ts\nfunction prepareResponseHeaders(init, { contentType }) {\n  var _a;\n  const headers = new Headers((_a = init == null ? void 0 : init.headers) != null ? _a : {});\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", contentType);\n  }\n  return headers;\n}\n\n// core/generate-object/generate-object.ts\nasync function generateObject({\n  model,\n  schema,\n  mode,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  ...settings\n}) {\n  var _a, _b;\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const jsonSchema = convertZodToJSONSchema(schema);\n  if (mode === \"auto\" || mode == null) {\n    mode = model.defaultObjectGenerationMode;\n  }\n  let result;\n  let finishReason;\n  let usage;\n  let warnings;\n  let rawResponse;\n  let logprobs;\n  switch (mode) {\n    case \"json\": {\n      const validatedPrompt = getValidatedPrompt({\n        system: injectJsonSchemaIntoSystem({ system, schema: jsonSchema }),\n        prompt,\n        messages\n      });\n      const generateResult = await retry(() => {\n        return model.doGenerate({\n          mode: { type: \"object-json\" },\n          ...prepareCallSettings(settings),\n          inputFormat: validatedPrompt.type,\n          prompt: convertToLanguageModelPrompt(validatedPrompt),\n          abortSignal,\n          headers\n        });\n      });\n      if (generateResult.text === void 0) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoObjectGeneratedError();\n      }\n      result = generateResult.text;\n      finishReason = generateResult.finishReason;\n      usage = generateResult.usage;\n      warnings = generateResult.warnings;\n      rawResponse = generateResult.rawResponse;\n      logprobs = generateResult.logprobs;\n      break;\n    }\n    case \"grammar\": {\n      const validatedPrompt = getValidatedPrompt({\n        system: injectJsonSchemaIntoSystem({ system, schema: jsonSchema }),\n        prompt,\n        messages\n      });\n      const generateResult = await retry(\n        () => model.doGenerate({\n          mode: { type: \"object-grammar\", schema: jsonSchema },\n          ...prepareCallSettings(settings),\n          inputFormat: validatedPrompt.type,\n          prompt: convertToLanguageModelPrompt(validatedPrompt),\n          abortSignal\n        })\n      );\n      if (generateResult.text === void 0) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoObjectGeneratedError();\n      }\n      result = generateResult.text;\n      finishReason = generateResult.finishReason;\n      usage = generateResult.usage;\n      warnings = generateResult.warnings;\n      rawResponse = generateResult.rawResponse;\n      logprobs = generateResult.logprobs;\n      break;\n    }\n    case \"tool\": {\n      const validatedPrompt = getValidatedPrompt({\n        system,\n        prompt,\n        messages\n      });\n      const generateResult = await retry(\n        () => model.doGenerate({\n          mode: {\n            type: \"object-tool\",\n            tool: {\n              type: \"function\",\n              name: \"json\",\n              description: \"Respond with a JSON object.\",\n              parameters: jsonSchema\n            }\n          },\n          ...prepareCallSettings(settings),\n          inputFormat: validatedPrompt.type,\n          prompt: convertToLanguageModelPrompt(validatedPrompt),\n          abortSignal\n        })\n      );\n      const functionArgs = (_b = (_a = generateResult.toolCalls) == null ? void 0 : _a[0]) == null ? void 0 : _b.args;\n      if (functionArgs === void 0) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoObjectGeneratedError();\n      }\n      result = functionArgs;\n      finishReason = generateResult.finishReason;\n      usage = generateResult.usage;\n      warnings = generateResult.warnings;\n      rawResponse = generateResult.rawResponse;\n      logprobs = generateResult.logprobs;\n      break;\n    }\n    case void 0: {\n      throw new Error(\"Model does not have a default object generation mode.\");\n    }\n    default: {\n      const _exhaustiveCheck = mode;\n      throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n    }\n  }\n  const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)({ text: result, schema });\n  if (!parseResult.success) {\n    throw parseResult.error;\n  }\n  return new GenerateObjectResult({\n    object: parseResult.value,\n    finishReason,\n    usage: calculateTokenUsage(usage),\n    warnings,\n    rawResponse,\n    logprobs\n  });\n}\nvar GenerateObjectResult = class {\n  constructor(options) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.rawResponse = options.rawResponse;\n    this.logprobs = options.logprobs;\n  }\n  /**\n  Converts the object to a JSON response.\n  The response will have a status code of 200 and a content type of `application/json; charset=utf-8`.\n     */\n  toJsonResponse(init) {\n    var _a;\n    return new Response(JSON.stringify(this.object), {\n      status: (_a = init == null ? void 0 : init.status) != null ? _a : 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"application/json; charset=utf-8\"\n      })\n    });\n  }\n};\nvar experimental_generateObject = generateObject;\n\n// core/generate-object/stream-object.ts\n\n\n\n// core/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source, transformer) {\n  const transformedStream = source.pipeThrough(\n    new TransformStream(transformer)\n  );\n  transformedStream[Symbol.asyncIterator] = () => {\n    const reader = transformedStream.getReader();\n    return {\n      async next() {\n        const { done, value } = await reader.read();\n        return done ? { done: true, value: void 0 } : { done: false, value };\n      }\n    };\n  };\n  return transformedStream;\n}\n\n// core/generate-object/stream-object.ts\nasync function streamObject({\n  model,\n  schema,\n  mode,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  onFinish,\n  ...settings\n}) {\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const jsonSchema = convertZodToJSONSchema(schema);\n  if (mode === \"auto\" || mode == null) {\n    mode = model.defaultObjectGenerationMode;\n  }\n  let callOptions;\n  let transformer;\n  switch (mode) {\n    case \"json\": {\n      const validatedPrompt = getValidatedPrompt({\n        system: injectJsonSchemaIntoSystem({ system, schema: jsonSchema }),\n        prompt,\n        messages\n      });\n      callOptions = {\n        mode: { type: \"object-json\" },\n        ...prepareCallSettings(settings),\n        inputFormat: validatedPrompt.type,\n        prompt: convertToLanguageModelPrompt(validatedPrompt),\n        abortSignal,\n        headers\n      };\n      transformer = {\n        transform: (chunk, controller) => {\n          switch (chunk.type) {\n            case \"text-delta\":\n              controller.enqueue(chunk.textDelta);\n              break;\n            case \"finish\":\n            case \"error\":\n              controller.enqueue(chunk);\n              break;\n          }\n        }\n      };\n      break;\n    }\n    case \"grammar\": {\n      const validatedPrompt = getValidatedPrompt({\n        system: injectJsonSchemaIntoSystem({ system, schema: jsonSchema }),\n        prompt,\n        messages\n      });\n      callOptions = {\n        mode: { type: \"object-grammar\", schema: jsonSchema },\n        ...prepareCallSettings(settings),\n        inputFormat: validatedPrompt.type,\n        prompt: convertToLanguageModelPrompt(validatedPrompt),\n        abortSignal,\n        headers\n      };\n      transformer = {\n        transform: (chunk, controller) => {\n          switch (chunk.type) {\n            case \"text-delta\":\n              controller.enqueue(chunk.textDelta);\n              break;\n            case \"finish\":\n            case \"error\":\n              controller.enqueue(chunk);\n              break;\n          }\n        }\n      };\n      break;\n    }\n    case \"tool\": {\n      const validatedPrompt = getValidatedPrompt({\n        system,\n        prompt,\n        messages\n      });\n      callOptions = {\n        mode: {\n          type: \"object-tool\",\n          tool: {\n            type: \"function\",\n            name: \"json\",\n            description: \"Respond with a JSON object.\",\n            parameters: jsonSchema\n          }\n        },\n        ...prepareCallSettings(settings),\n        inputFormat: validatedPrompt.type,\n        prompt: convertToLanguageModelPrompt(validatedPrompt),\n        abortSignal,\n        headers\n      };\n      transformer = {\n        transform(chunk, controller) {\n          switch (chunk.type) {\n            case \"tool-call-delta\":\n              controller.enqueue(chunk.argsTextDelta);\n              break;\n            case \"finish\":\n            case \"error\":\n              controller.enqueue(chunk);\n              break;\n          }\n        }\n      };\n      break;\n    }\n    case void 0: {\n      throw new Error(\"Model does not have a default object generation mode.\");\n    }\n    default: {\n      const _exhaustiveCheck = mode;\n      throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n    }\n  }\n  const result = await retry(() => model.doStream(callOptions));\n  return new StreamObjectResult({\n    stream: result.stream.pipeThrough(new TransformStream(transformer)),\n    warnings: result.warnings,\n    rawResponse: result.rawResponse,\n    schema,\n    onFinish\n  });\n}\nvar StreamObjectResult = class {\n  constructor({\n    stream,\n    warnings,\n    rawResponse,\n    schema,\n    onFinish\n  }) {\n    this.warnings = warnings;\n    this.rawResponse = rawResponse;\n    let resolveObject;\n    let rejectObject;\n    this.object = new Promise((resolve, reject) => {\n      resolveObject = resolve;\n      rejectObject = reject;\n    });\n    let resolveUsage;\n    this.usage = new Promise((resolve) => {\n      resolveUsage = resolve;\n    });\n    let usage;\n    let object;\n    let error;\n    let accumulatedText = \"\";\n    let delta = \"\";\n    let latestObject = void 0;\n    this.originalStream = stream.pipeThrough(\n      new TransformStream({\n        async transform(chunk, controller) {\n          if (typeof chunk === \"string\") {\n            accumulatedText += chunk;\n            delta += chunk;\n            const currentObject = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.parsePartialJson)(\n              accumulatedText\n            );\n            if (!(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.isDeepEqualData)(latestObject, currentObject)) {\n              latestObject = currentObject;\n              controller.enqueue({\n                type: \"object\",\n                object: currentObject\n              });\n              controller.enqueue({\n                type: \"text-delta\",\n                textDelta: delta\n              });\n              delta = \"\";\n            }\n            return;\n          }\n          switch (chunk.type) {\n            case \"finish\": {\n              if (delta !== \"\") {\n                controller.enqueue({\n                  type: \"text-delta\",\n                  textDelta: delta\n                });\n              }\n              usage = calculateTokenUsage(chunk.usage);\n              controller.enqueue({ ...chunk, usage });\n              resolveUsage(usage);\n              const validationResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.safeValidateTypes)({\n                value: latestObject,\n                schema\n              });\n              if (validationResult.success) {\n                object = validationResult.value;\n                resolveObject(object);\n              } else {\n                error = validationResult.error;\n                rejectObject(error);\n              }\n              break;\n            }\n            default: {\n              controller.enqueue(chunk);\n              break;\n            }\n          }\n        },\n        // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n        async flush(controller) {\n          try {\n            await (onFinish == null ? void 0 : onFinish({\n              usage: usage != null ? usage : {\n                promptTokens: NaN,\n                completionTokens: NaN,\n                totalTokens: NaN\n              },\n              object,\n              error,\n              rawResponse,\n              warnings\n            }));\n          } catch (error2) {\n            controller.error(error2);\n          }\n        }\n      })\n    );\n  }\n  /**\n  Stream of partial objects. It gets more complete as the stream progresses.\n    \n  Note that the partial object is not validated. \n  If you want to be certain that the actual content matches your schema, you need to implement your own validation for partial results.\n     */\n  get partialObjectStream() {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        switch (chunk.type) {\n          case \"object\":\n            controller.enqueue(chunk.object);\n            break;\n          case \"text-delta\":\n          case \"finish\":\n            break;\n          case \"error\":\n            controller.error(chunk.error);\n            break;\n          default: {\n            const _exhaustiveCheck = chunk;\n            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n          }\n        }\n      }\n    });\n  }\n  /**\n  Text stream of the JSON representation of the generated object. It contains text chunks. \n  When the stream is finished, the object is valid JSON that can be parsed.\n     */\n  get textStream() {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        switch (chunk.type) {\n          case \"text-delta\":\n            controller.enqueue(chunk.textDelta);\n            break;\n          case \"object\":\n          case \"finish\":\n            break;\n          case \"error\":\n            controller.error(chunk.error);\n            break;\n          default: {\n            const _exhaustiveCheck = chunk;\n            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n          }\n        }\n      }\n    });\n  }\n  /**\n  Stream of different types of events, including partial objects, errors, and finish events.\n     */\n  get fullStream() {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n      }\n    });\n  }\n  /**\n  Writes text delta output to a Node.js response-like object.\n  It sets a `Content-Type` header to `text/plain; charset=utf-8` and \n  writes each text delta as a separate chunk.\n  \n  @param response A Node.js response-like object (ServerResponse).\n  @param init Optional headers and status code.\n     */\n  pipeTextStreamToResponse(response, init) {\n    var _a;\n    response.writeHead((_a = init == null ? void 0 : init.status) != null ? _a : 200, {\n      \"Content-Type\": \"text/plain; charset=utf-8\",\n      ...init == null ? void 0 : init.headers\n    });\n    const reader = this.textStream.pipeThrough(new TextEncoderStream()).getReader();\n    const read = async () => {\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done)\n            break;\n          response.write(value);\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        response.end();\n      }\n    };\n    read();\n  }\n  /**\n  Creates a simple text stream response.\n  The response has a `Content-Type` header set to `text/plain; charset=utf-8`.\n  Each text delta is encoded as UTF-8 and sent as a separate chunk.\n  Non-text-delta events are ignored.\n  \n  @param init Optional headers and status code.\n     */\n  toTextStreamResponse(init) {\n    var _a;\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: (_a = init == null ? void 0 : init.status) != null ? _a : 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\"\n      })\n    });\n  }\n};\nvar experimental_streamObject = streamObject;\n\n// core/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object) {\n  return object != null && Object.keys(object).length > 0;\n}\n\n// core/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({\n  tools,\n  toolChoice\n}) {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: void 0,\n      toolChoice: void 0\n    };\n  }\n  return {\n    tools: Object.entries(tools).map(([name, tool2]) => ({\n      type: \"function\",\n      name,\n      description: tool2.description,\n      parameters: convertZodToJSONSchema(tool2.parameters)\n    })),\n    toolChoice: toolChoice == null ? { type: \"auto\" } : typeof toolChoice === \"string\" ? { type: toolChoice } : { type: \"tool\", toolName: toolChoice.toolName }\n  };\n}\n\n// core/generate-text/tool-call.ts\n\n\nfunction parseToolCall({\n  toolCall,\n  tools\n}) {\n  const toolName = toolCall.toolName;\n  if (tools == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchToolError({ toolName: toolCall.toolName });\n  }\n  const tool2 = tools[toolName];\n  if (tool2 == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools)\n    });\n  }\n  const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)({\n    text: toolCall.args,\n    schema: tool2.parameters\n  });\n  if (parseResult.success === false) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidToolArgumentsError({\n      toolName,\n      toolArgs: toolCall.args,\n      cause: parseResult.error\n    });\n  }\n  return {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    args: parseResult.value\n  };\n}\n\n// core/generate-text/generate-text.ts\nasync function generateText({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  maxAutomaticRoundtrips = 0,\n  maxToolRoundtrips = maxAutomaticRoundtrips,\n  ...settings\n}) {\n  var _a, _b, _c;\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const validatedPrompt = getValidatedPrompt({ system, prompt, messages });\n  const mode = {\n    type: \"regular\",\n    ...prepareToolsAndToolChoice({ tools, toolChoice })\n  };\n  const callSettings = prepareCallSettings(settings);\n  const promptMessages = convertToLanguageModelPrompt(validatedPrompt);\n  let currentModelResponse;\n  let currentToolCalls = [];\n  let currentToolResults = [];\n  let roundtrips = 0;\n  const responseMessages = [];\n  do {\n    currentModelResponse = await retry(() => {\n      return model.doGenerate({\n        mode,\n        ...callSettings,\n        // once we have a roundtrip, we need to switch to messages format:\n        inputFormat: roundtrips === 0 ? validatedPrompt.type : \"messages\",\n        prompt: promptMessages,\n        abortSignal,\n        headers\n      });\n    });\n    currentToolCalls = ((_a = currentModelResponse.toolCalls) != null ? _a : []).map(\n      (modelToolCall) => parseToolCall({ toolCall: modelToolCall, tools })\n    );\n    currentToolResults = tools == null ? [] : await executeTools({ toolCalls: currentToolCalls, tools });\n    const newResponseMessages = toResponseMessages({\n      text: (_b = currentModelResponse.text) != null ? _b : \"\",\n      toolCalls: currentToolCalls,\n      toolResults: currentToolResults\n    });\n    responseMessages.push(...newResponseMessages);\n    promptMessages.push(\n      ...newResponseMessages.map(convertToLanguageModelMessage)\n    );\n  } while (\n    // there are tool calls:\n    currentToolCalls.length > 0 && // all current tool calls have results:\n    currentToolResults.length === currentToolCalls.length && // the number of roundtrips is less than the maximum:\n    roundtrips++ < maxToolRoundtrips\n  );\n  return new GenerateTextResult({\n    // Always return a string so that the caller doesn't have to check for undefined.\n    // If they need to check if the model did not return any text,\n    // they can check the length of the string:\n    text: (_c = currentModelResponse.text) != null ? _c : \"\",\n    toolCalls: currentToolCalls,\n    toolResults: currentToolResults,\n    finishReason: currentModelResponse.finishReason,\n    usage: calculateTokenUsage(currentModelResponse.usage),\n    warnings: currentModelResponse.warnings,\n    rawResponse: currentModelResponse.rawResponse,\n    logprobs: currentModelResponse.logprobs,\n    responseMessages\n  });\n}\nasync function executeTools({\n  toolCalls,\n  tools\n}) {\n  const toolResults = await Promise.all(\n    toolCalls.map(async (toolCall) => {\n      const tool2 = tools[toolCall.toolName];\n      if ((tool2 == null ? void 0 : tool2.execute) == null) {\n        return void 0;\n      }\n      const result = await tool2.execute(toolCall.args);\n      return {\n        toolCallId: toolCall.toolCallId,\n        toolName: toolCall.toolName,\n        args: toolCall.args,\n        result\n      };\n    })\n  );\n  return toolResults.filter(\n    (result) => result != null\n  );\n}\nvar GenerateTextResult = class {\n  constructor(options) {\n    this.text = options.text;\n    this.toolCalls = options.toolCalls;\n    this.toolResults = options.toolResults;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.rawResponse = options.rawResponse;\n    this.logprobs = options.logprobs;\n    this.responseMessages = options.responseMessages;\n  }\n};\nfunction toResponseMessages({\n  text,\n  toolCalls,\n  toolResults\n}) {\n  const responseMessages = [];\n  responseMessages.push({\n    role: \"assistant\",\n    content: [{ type: \"text\", text }, ...toolCalls]\n  });\n  if (toolResults.length > 0) {\n    responseMessages.push({\n      role: \"tool\",\n      content: toolResults.map((result) => ({\n        type: \"tool-result\",\n        toolCallId: result.toolCallId,\n        toolName: result.toolName,\n        result: result.result\n      }))\n    });\n  }\n  return responseMessages;\n}\nvar experimental_generateText = generateText;\n\n// core/generate-text/run-tools-transformation.ts\n\n\nfunction runToolsTransformation({\n  tools,\n  generatorStream\n}) {\n  let canClose = false;\n  const outstandingToolCalls = /* @__PURE__ */ new Set();\n  let toolResultsStreamController = null;\n  const toolResultsStream = new ReadableStream({\n    start(controller) {\n      toolResultsStreamController = controller;\n    }\n  });\n  const forwardStream = new TransformStream({\n    transform(chunk, controller) {\n      const chunkType = chunk.type;\n      switch (chunkType) {\n        case \"text-delta\":\n        case \"error\": {\n          controller.enqueue(chunk);\n          break;\n        }\n        case \"tool-call\": {\n          const toolName = chunk.toolName;\n          if (tools == null) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchToolError({ toolName: chunk.toolName })\n            });\n            break;\n          }\n          const tool2 = tools[toolName];\n          if (tool2 == null) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchToolError({\n                toolName: chunk.toolName,\n                availableTools: Object.keys(tools)\n              })\n            });\n            break;\n          }\n          try {\n            const toolCall = parseToolCall({\n              toolCall: chunk,\n              tools\n            });\n            controller.enqueue(toolCall);\n            if (tool2.execute != null) {\n              const toolExecutionId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)();\n              outstandingToolCalls.add(toolExecutionId);\n              tool2.execute(toolCall.args).then(\n                (result) => {\n                  toolResultsStreamController.enqueue({\n                    ...toolCall,\n                    type: \"tool-result\",\n                    result\n                  });\n                  outstandingToolCalls.delete(toolExecutionId);\n                  if (canClose && outstandingToolCalls.size === 0) {\n                    toolResultsStreamController.close();\n                  }\n                },\n                (error) => {\n                  toolResultsStreamController.enqueue({\n                    type: \"error\",\n                    error\n                  });\n                  outstandingToolCalls.delete(toolExecutionId);\n                  if (canClose && outstandingToolCalls.size === 0) {\n                    toolResultsStreamController.close();\n                  }\n                }\n              );\n            }\n          } catch (error) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error\n            });\n          }\n          break;\n        }\n        case \"finish\": {\n          controller.enqueue({\n            type: \"finish\",\n            finishReason: chunk.finishReason,\n            logprobs: chunk.logprobs,\n            usage: calculateTokenUsage(chunk.usage)\n          });\n          break;\n        }\n        case \"tool-call-delta\": {\n          break;\n        }\n        default: {\n          const _exhaustiveCheck = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    flush() {\n      canClose = true;\n      if (outstandingToolCalls.size === 0) {\n        toolResultsStreamController.close();\n      }\n    }\n  });\n  return new ReadableStream({\n    async start(controller) {\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n            }\n          })\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            }\n          })\n        )\n      ]);\n    }\n  });\n}\n\n// core/generate-text/stream-text.ts\nasync function streamText({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  onFinish,\n  ...settings\n}) {\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const validatedPrompt = getValidatedPrompt({ system, prompt, messages });\n  const { stream, warnings, rawResponse } = await retry(\n    () => model.doStream({\n      mode: {\n        type: \"regular\",\n        ...prepareToolsAndToolChoice({ tools, toolChoice })\n      },\n      ...prepareCallSettings(settings),\n      inputFormat: validatedPrompt.type,\n      prompt: convertToLanguageModelPrompt(validatedPrompt),\n      abortSignal,\n      headers\n    })\n  );\n  return new StreamTextResult({\n    stream: runToolsTransformation({\n      tools,\n      generatorStream: stream\n    }),\n    warnings,\n    rawResponse,\n    onFinish\n  });\n}\nvar StreamTextResult = class {\n  constructor({\n    stream,\n    warnings,\n    rawResponse,\n    onFinish\n  }) {\n    this.warnings = warnings;\n    this.rawResponse = rawResponse;\n    this.onFinish = onFinish;\n    let resolveUsage;\n    this.usage = new Promise((resolve) => {\n      resolveUsage = resolve;\n    });\n    let resolveFinishReason;\n    this.finishReason = new Promise((resolve) => {\n      resolveFinishReason = resolve;\n    });\n    let resolveText;\n    this.text = new Promise((resolve) => {\n      resolveText = resolve;\n    });\n    let resolveToolCalls;\n    this.toolCalls = new Promise((resolve) => {\n      resolveToolCalls = resolve;\n    });\n    let resolveToolResults;\n    this.toolResults = new Promise((resolve) => {\n      resolveToolResults = resolve;\n    });\n    let finishReason;\n    let usage;\n    let text = \"\";\n    const toolCalls = [];\n    const toolResults = [];\n    const self = this;\n    this.originalStream = stream.pipeThrough(\n      new TransformStream({\n        async transform(chunk, controller) {\n          controller.enqueue(chunk);\n          if (chunk.type === \"text-delta\") {\n            text += chunk.textDelta;\n          }\n          if (chunk.type === \"tool-call\") {\n            toolCalls.push(chunk);\n          }\n          if (chunk.type === \"tool-result\") {\n            toolResults.push(chunk);\n          }\n          if (chunk.type === \"finish\") {\n            usage = chunk.usage;\n            finishReason = chunk.finishReason;\n            resolveUsage(usage);\n            resolveFinishReason(finishReason);\n            resolveText(text);\n            resolveToolCalls(toolCalls);\n          }\n        },\n        // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n        async flush(controller) {\n          var _a;\n          try {\n            resolveToolResults(toolResults);\n            await ((_a = self.onFinish) == null ? void 0 : _a.call(self, {\n              finishReason: finishReason != null ? finishReason : \"unknown\",\n              usage: usage != null ? usage : {\n                promptTokens: NaN,\n                completionTokens: NaN,\n                totalTokens: NaN\n              },\n              text,\n              toolCalls,\n              // The tool results are inferred as a never[] type, because they are\n              // optional and the execute method with an inferred result type is\n              // optional as well. Therefore we need to cast the toolResults to any.\n              // The type exposed to the users will be correctly inferred.\n              toolResults,\n              rawResponse,\n              warnings\n            }));\n          } catch (error) {\n            controller.error(error);\n          }\n        }\n      })\n    );\n  }\n  /**\n  Split out a new stream from the original stream.\n  The original stream is replaced to allow for further splitting,\n  since we do not know how many times the stream will be split.\n  \n  Note: this leads to buffering the stream content on the server.\n  However, the LLM results are expected to be small enough to not cause issues.\n     */\n  teeStream() {\n    const [stream1, stream2] = this.originalStream.tee();\n    this.originalStream = stream2;\n    return stream1;\n  }\n  /**\n  A text stream that returns only the generated text deltas. You can use it\n  as either an AsyncIterable or a ReadableStream. When an error occurs, the\n  stream will throw the error.\n     */\n  get textStream() {\n    return createAsyncIterableStream(this.teeStream(), {\n      transform(chunk, controller) {\n        if (chunk.type === \"text-delta\") {\n          if (chunk.textDelta.length > 0) {\n            controller.enqueue(chunk.textDelta);\n          }\n        } else if (chunk.type === \"error\") {\n          throw chunk.error;\n        }\n      }\n    });\n  }\n  /**\n  A stream with all events, including text deltas, tool calls, tool results, and\n  errors.\n  You can use it as either an AsyncIterable or a ReadableStream. When an error occurs, the\n  stream will throw the error.\n     */\n  get fullStream() {\n    return createAsyncIterableStream(this.teeStream(), {\n      transform(chunk, controller) {\n        if (chunk.type === \"text-delta\") {\n          if (chunk.textDelta.length > 0) {\n            controller.enqueue(chunk);\n          }\n        } else {\n          controller.enqueue(chunk);\n        }\n      }\n    });\n  }\n  /**\n  Converts the result to an `AIStream` object that is compatible with `StreamingTextResponse`.\n  It can be used with the `useChat` and `useCompletion` hooks.\n  \n  @param callbacks \n  Stream callbacks that will be called when the stream emits events.\n  \n  @returns an `AIStream` object.\n     */\n  toAIStream(callbacks = {}) {\n    let aggregatedResponse = \"\";\n    const callbackTransformer = new TransformStream({\n      async start() {\n        if (callbacks.onStart)\n          await callbacks.onStart();\n      },\n      async transform(chunk, controller) {\n        controller.enqueue(chunk);\n        if (chunk.type === \"text-delta\") {\n          const textDelta = chunk.textDelta;\n          aggregatedResponse += textDelta;\n          if (callbacks.onToken)\n            await callbacks.onToken(textDelta);\n          if (callbacks.onText)\n            await callbacks.onText(textDelta);\n        }\n      },\n      async flush() {\n        if (callbacks.onCompletion)\n          await callbacks.onCompletion(aggregatedResponse);\n        if (callbacks.onFinal)\n          await callbacks.onFinal(aggregatedResponse);\n      }\n    });\n    const streamDataTransformer = new TransformStream({\n      transform: async (chunk, controller) => {\n        switch (chunk.type) {\n          case \"text-delta\":\n            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"text\", chunk.textDelta));\n            break;\n          case \"tool-call\":\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"tool_call\", {\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                args: chunk.args\n              })\n            );\n            break;\n          case \"tool-result\":\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"tool_result\", {\n                toolCallId: chunk.toolCallId,\n                toolName: chunk.toolName,\n                args: chunk.args,\n                result: chunk.result\n              })\n            );\n            break;\n          case \"error\":\n            controller.enqueue(\n              (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"error\", JSON.stringify(chunk.error))\n            );\n            break;\n        }\n      }\n    });\n    return this.fullStream.pipeThrough(callbackTransformer).pipeThrough(streamDataTransformer).pipeThrough(new TextEncoderStream());\n  }\n  /**\n  Writes stream data output to a Node.js response-like object.\n  It sets a `Content-Type` header to `text/plain; charset=utf-8` and \n  writes each stream data part as a separate chunk.\n  \n  @param response A Node.js response-like object (ServerResponse).\n  @param init Optional headers and status code.\n     */\n  pipeAIStreamToResponse(response, init) {\n    var _a;\n    response.writeHead((_a = init == null ? void 0 : init.status) != null ? _a : 200, {\n      \"Content-Type\": \"text/plain; charset=utf-8\",\n      ...init == null ? void 0 : init.headers\n    });\n    const reader = this.toAIStream().getReader();\n    const read = async () => {\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done)\n            break;\n          response.write(value);\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        response.end();\n      }\n    };\n    read();\n  }\n  /**\n  Writes text delta output to a Node.js response-like object.\n  It sets a `Content-Type` header to `text/plain; charset=utf-8` and \n  writes each text delta as a separate chunk.\n  \n  @param response A Node.js response-like object (ServerResponse).\n  @param init Optional headers and status code.\n     */\n  pipeTextStreamToResponse(response, init) {\n    var _a;\n    response.writeHead((_a = init == null ? void 0 : init.status) != null ? _a : 200, {\n      \"Content-Type\": \"text/plain; charset=utf-8\",\n      ...init == null ? void 0 : init.headers\n    });\n    const reader = this.textStream.pipeThrough(new TextEncoderStream()).getReader();\n    const read = async () => {\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done)\n            break;\n          response.write(value);\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        response.end();\n      }\n    };\n    read();\n  }\n  /**\n  Converts the result to a streamed response object with a stream data part stream.\n  It can be used with the `useChat` and `useCompletion` hooks.\n  \n  @param init Optional headers.\n  \n  @return A response object.\n     */\n  toAIStreamResponse(init) {\n    return new StreamingTextResponse(this.toAIStream(), init);\n  }\n  /**\n  Creates a simple text stream response.\n  Each text delta is encoded as UTF-8 and sent as a separate chunk.\n  Non-text-delta events are ignored.\n  \n  @param init Optional headers and status code.\n     */\n  toTextStreamResponse(init) {\n    var _a;\n    return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n      status: (_a = init == null ? void 0 : init.status) != null ? _a : 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\"\n      })\n    });\n  }\n};\nvar experimental_streamText = streamText;\n\n// core/prompt/convert-to-core-messages.ts\nfunction convertToCoreMessages(messages) {\n  const coreMessages = [];\n  for (const { role, content, toolInvocations } of messages) {\n    switch (role) {\n      case \"user\": {\n        coreMessages.push({ role: \"user\", content });\n        break;\n      }\n      case \"assistant\": {\n        if (toolInvocations == null) {\n          coreMessages.push({ role: \"assistant\", content });\n          break;\n        }\n        coreMessages.push({\n          role: \"assistant\",\n          content: [\n            { type: \"text\", text: content },\n            ...toolInvocations.map(({ toolCallId, toolName, args }) => ({\n              type: \"tool-call\",\n              toolCallId,\n              toolName,\n              args\n            }))\n          ]\n        });\n        coreMessages.push({\n          role: \"tool\",\n          content: toolInvocations.map(\n            ({ toolCallId, toolName, args, result }) => ({\n              type: \"tool-result\",\n              toolCallId,\n              toolName,\n              args,\n              result\n            })\n          )\n        });\n        break;\n      }\n      default: {\n        const _exhaustiveCheck = role;\n        throw new Error(`Unhandled role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n  return coreMessages;\n}\n\n// core/registry/invalid-model-id-error.ts\nvar InvalidModelIdError = class extends Error {\n  constructor({\n    id,\n    message = `Invalid model id: ${id}`\n  }) {\n    super(message);\n    this.name = \"AI_InvalidModelIdError\";\n    this.id = id;\n  }\n  static isInvalidModelIdError(error) {\n    return error instanceof Error && error.name === \"AI_InvalidModelIdError\" && typeof error.id === \"string\";\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      id: this.id\n    };\n  }\n};\n\n// core/registry/no-such-model-error.ts\nvar NoSuchModelError = class extends Error {\n  constructor({\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`\n  }) {\n    super(message);\n    this.name = \"AI_NoSuchModelError\";\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n  static isNoSuchModelError(error) {\n    return error instanceof Error && error.name === \"AI_NoSuchModelError\" && typeof error.modelId === \"string\" && typeof error.modelType === \"string\";\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      modelId: this.modelId,\n      modelType: this.modelType\n    };\n  }\n};\n\n// core/registry/no-such-provider-error.ts\nvar NoSuchProviderError = class extends Error {\n  constructor({\n    providerId,\n    availableProviders,\n    message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})`\n  }) {\n    super(message);\n    this.name = \"AI_NoSuchProviderError\";\n    this.providerId = providerId;\n    this.availableProviders = availableProviders;\n  }\n  static isNoSuchProviderError(error) {\n    return error instanceof Error && error.name === \"AI_NoSuchProviderError\" && typeof error.providerId === \"string\" && Array.isArray(error.availableProviders);\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      providerId: this.providerId,\n      availableProviders: this.availableProviders\n    };\n  }\n};\n\n// core/registry/provider-registry.ts\nfunction experimental_createProviderRegistry(providers) {\n  const registry = new DefaultProviderRegistry();\n  for (const [id, provider] of Object.entries(providers)) {\n    registry.registerProvider({ id, provider });\n  }\n  return registry;\n}\nvar experimental_createModelRegistry = experimental_createProviderRegistry;\nvar DefaultProviderRegistry = class {\n  constructor() {\n    this.providers = {};\n  }\n  registerProvider({ id, provider }) {\n    this.providers[id] = provider;\n  }\n  getProvider(id) {\n    const provider = this.providers[id];\n    if (provider == null) {\n      throw new NoSuchProviderError({\n        providerId: id,\n        availableProviders: Object.keys(this.providers)\n      });\n    }\n    return provider;\n  }\n  splitId(id) {\n    const index = id.indexOf(\":\");\n    if (index === -1) {\n      throw new InvalidModelIdError({ id });\n    }\n    return [id.slice(0, index), id.slice(index + 1)];\n  }\n  languageModel(id) {\n    var _a, _b;\n    const [providerId, modelId] = this.splitId(id);\n    const model = (_b = (_a = this.getProvider(providerId)).languageModel) == null ? void 0 : _b.call(_a, modelId);\n    if (model == null) {\n      throw new NoSuchModelError({ modelId: id, modelType: \"language model\" });\n    }\n    return model;\n  }\n  textEmbeddingModel(id) {\n    var _a, _b;\n    const [providerId, modelId] = this.splitId(id);\n    const model = (_b = (_a = this.getProvider(providerId)).textEmbedding) == null ? void 0 : _b.call(_a, modelId);\n    if (model == null) {\n      throw new NoSuchModelError({\n        modelId: id,\n        modelType: \"text embedding model\"\n      });\n    }\n    return model;\n  }\n};\n\n// core/tool/tool.ts\nfunction tool(tool2) {\n  return tool2;\n}\n\n// core/types/errors.ts\n\n\n// core/util/cosine-similarity.ts\nfunction cosineSimilarity(vector1, vector2) {\n  if (vector1.length !== vector2.length) {\n    throw new Error(\n      `Vectors must have the same length (vector1: ${vector1.length} elements, vector2: ${vector2.length} elements)`\n    );\n  }\n  return dotProduct(vector1, vector2) / (magnitude(vector1) * magnitude(vector2));\n}\nfunction dotProduct(vector1, vector2) {\n  return vector1.reduce(\n    (accumulator, value, index) => accumulator + value * vector2[index],\n    0\n  );\n}\nfunction magnitude(vector) {\n  return Math.sqrt(dotProduct(vector, vector));\n}\n\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n  const textDecoder = new TextDecoder();\n  let eventSourceParser;\n  return new TransformStream({\n    async start(controller) {\n      eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_4__.createParser)(\n        (event) => {\n          if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n          // @see https://replicate.com/docs/streaming\n          event.event === \"done\") {\n            controller.terminate();\n            return;\n          }\n          if (\"data\" in event) {\n            const parsedMessage = customParser ? customParser(event.data, {\n              event: event.event\n            }) : event.data;\n            if (parsedMessage)\n              controller.enqueue(parsedMessage);\n          }\n        }\n      );\n    },\n    transform(chunk) {\n      eventSourceParser.feed(textDecoder.decode(chunk));\n    }\n  });\n}\nfunction createCallbacksTransformer(cb) {\n  const textEncoder = new TextEncoder();\n  let aggregatedResponse = \"\";\n  const callbacks = cb || {};\n  return new TransformStream({\n    async start() {\n      if (callbacks.onStart)\n        await callbacks.onStart();\n    },\n    async transform(message, controller) {\n      const content = typeof message === \"string\" ? message : message.content;\n      controller.enqueue(textEncoder.encode(content));\n      aggregatedResponse += content;\n      if (callbacks.onToken)\n        await callbacks.onToken(content);\n      if (callbacks.onText && typeof message === \"string\") {\n        await callbacks.onText(message);\n      }\n    },\n    async flush() {\n      const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n      if (callbacks.onCompletion) {\n        await callbacks.onCompletion(aggregatedResponse);\n      }\n      if (callbacks.onFinal && !isOpenAICallbacks) {\n        await callbacks.onFinal(aggregatedResponse);\n      }\n    }\n  });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n  return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n  let isStreamStart = true;\n  return (text) => {\n    if (isStreamStart) {\n      text = text.trimStart();\n      if (text)\n        isStreamStart = false;\n    }\n    return text;\n  };\n}\nfunction AIStream(response, customParser, callbacks) {\n  if (!response.ok) {\n    if (response.body) {\n      const reader = response.body.getReader();\n      return new ReadableStream({\n        async start(controller) {\n          const { done, value } = await reader.read();\n          if (!done) {\n            const errorText = new TextDecoder().decode(value);\n            controller.error(new Error(`Response error: ${errorText}`));\n          }\n        }\n      });\n    } else {\n      return new ReadableStream({\n        start(controller) {\n          controller.error(new Error(\"Response error: No response body\"));\n        }\n      });\n    }\n  }\n  const responseBodyStream = response.body || createEmptyReadableStream();\n  return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n  return new ReadableStream({\n    start(controller) {\n      controller.close();\n    }\n  });\n}\nfunction readableFromAsyncIterable(iterable) {\n  let it = iterable[Symbol.asyncIterator]();\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await it.next();\n      if (done)\n        controller.close();\n      else\n        controller.enqueue(value);\n    },\n    async cancel(reason) {\n      var _a;\n      await ((_a = it.return) == null ? void 0 : _a.call(it, reason));\n    }\n  });\n}\n\n// streams/stream-data.ts\n\nvar StreamData = class {\n  constructor() {\n    this.encoder = new TextEncoder();\n    this.controller = null;\n    this.isClosed = false;\n    this.warningTimeout = null;\n    const self = this;\n    this.stream = new ReadableStream({\n      start: async (controller) => {\n        self.controller = controller;\n        if (true) {\n          self.warningTimeout = setTimeout(() => {\n            console.warn(\n              \"The data stream is hanging. Did you forget to close it with `data.close()`?\"\n            );\n          }, 3e3);\n        }\n      },\n      pull: (controller) => {\n      },\n      cancel: (reason) => {\n        this.isClosed = true;\n      }\n    });\n  }\n  async close() {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    this.controller.close();\n    this.isClosed = true;\n    if (this.warningTimeout) {\n      clearTimeout(this.warningTimeout);\n    }\n  }\n  append(value) {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    this.controller.enqueue(\n      this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"data\", [value]))\n    );\n  }\n  appendMessageAnnotation(value) {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    this.controller.enqueue(\n      this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"message_annotations\", [value]))\n    );\n  }\n};\nfunction createStreamDataTransformer() {\n  const encoder = new TextEncoder();\n  const decoder = new TextDecoder();\n  return new TransformStream({\n    transform: async (chunk, controller) => {\n      const message = decoder.decode(chunk);\n      controller.enqueue(encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"text\", message)));\n    }\n  });\n}\nvar experimental_StreamData = class extends StreamData {\n};\n\n// streams/anthropic-stream.ts\nfunction parseAnthropicStream() {\n  let previous = \"\";\n  return (data) => {\n    const json = JSON.parse(data);\n    if (\"error\" in json) {\n      throw new Error(`${json.error.type}: ${json.error.message}`);\n    }\n    if (!(\"completion\" in json)) {\n      return;\n    }\n    const text = json.completion;\n    if (!previous || text.length > previous.length && text.startsWith(previous)) {\n      const delta = text.slice(previous.length);\n      previous = text;\n      return delta;\n    }\n    return text;\n  };\n}\nasync function* streamable(stream) {\n  for await (const chunk of stream) {\n    if (\"completion\" in chunk) {\n      const text = chunk.completion;\n      if (text)\n        yield text;\n    } else if (\"delta\" in chunk) {\n      const { delta } = chunk;\n      if (\"text\" in delta) {\n        const text = delta.text;\n        if (text)\n          yield text;\n      }\n    }\n  }\n}\nfunction AnthropicStream(res, cb) {\n  if (Symbol.asyncIterator in res) {\n    return readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n  } else {\n    return AIStream(res, parseAnthropicStream(), cb).pipeThrough(\n      createStreamDataTransformer()\n    );\n  }\n}\n\n// streams/assistant-response.ts\n\nfunction AssistantResponse({ threadId, messageId }, process2) {\n  const stream = new ReadableStream({\n    async start(controller) {\n      var _a;\n      const textEncoder = new TextEncoder();\n      const sendMessage = (message) => {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"assistant_message\", message))\n        );\n      };\n      const sendDataMessage = (message) => {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"data_message\", message))\n        );\n      };\n      const sendError = (errorMessage) => {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"error\", errorMessage))\n        );\n      };\n      const forwardStream = async (stream2) => {\n        var _a2, _b;\n        let result = void 0;\n        for await (const value of stream2) {\n          switch (value.event) {\n            case \"thread.message.created\": {\n              controller.enqueue(\n                textEncoder.encode(\n                  (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"assistant_message\", {\n                    id: value.data.id,\n                    role: \"assistant\",\n                    content: [{ type: \"text\", text: { value: \"\" } }]\n                  })\n                )\n              );\n              break;\n            }\n            case \"thread.message.delta\": {\n              const content = (_a2 = value.data.delta.content) == null ? void 0 : _a2[0];\n              if ((content == null ? void 0 : content.type) === \"text\" && ((_b = content.text) == null ? void 0 : _b.value) != null) {\n                controller.enqueue(\n                  textEncoder.encode(\n                    (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"text\", content.text.value)\n                  )\n                );\n              }\n              break;\n            }\n            case \"thread.run.completed\":\n            case \"thread.run.requires_action\": {\n              result = value.data;\n              break;\n            }\n          }\n        }\n        return result;\n      };\n      controller.enqueue(\n        textEncoder.encode(\n          (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"assistant_control_data\", {\n            threadId,\n            messageId\n          })\n        )\n      );\n      try {\n        await process2({\n          threadId,\n          messageId,\n          sendMessage,\n          sendDataMessage,\n          forwardStream\n        });\n      } catch (error) {\n        sendError((_a = error.message) != null ? _a : `${error}`);\n      } finally {\n        controller.close();\n      }\n    },\n    pull(controller) {\n    },\n    cancel() {\n    }\n  });\n  return new Response(stream, {\n    status: 200,\n    headers: {\n      \"Content-Type\": \"text/plain; charset=utf-8\"\n    }\n  });\n}\nvar experimental_AssistantResponse = AssistantResponse;\n\n// streams/aws-bedrock-stream.ts\nasync function* asDeltaIterable(response, extractTextDeltaFromChunk) {\n  var _a, _b;\n  const decoder = new TextDecoder();\n  for await (const chunk of (_a = response.body) != null ? _a : []) {\n    const bytes = (_b = chunk.chunk) == null ? void 0 : _b.bytes;\n    if (bytes != null) {\n      const chunkText = decoder.decode(bytes);\n      const chunkJSON = JSON.parse(chunkText);\n      const delta = extractTextDeltaFromChunk(chunkJSON);\n      if (delta != null) {\n        yield delta;\n      }\n    }\n  }\n}\nfunction AWSBedrockAnthropicMessagesStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => {\n    var _a;\n    return (_a = chunk.delta) == null ? void 0 : _a.text;\n  });\n}\nfunction AWSBedrockAnthropicStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk.completion);\n}\nfunction AWSBedrockCohereStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk == null ? void 0 : chunk.text);\n}\nfunction AWSBedrockLlama2Stream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk.generation);\n}\nfunction AWSBedrockStream(response, callbacks, extractTextDeltaFromChunk) {\n  return readableFromAsyncIterable(\n    asDeltaIterable(response, extractTextDeltaFromChunk)\n  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/cohere-stream.ts\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nasync function processLines(lines, controller) {\n  for (const line of lines) {\n    const { text, is_finished } = JSON.parse(line);\n    if (!is_finished) {\n      controller.enqueue(text);\n    }\n  }\n}\nasync function readAndProcessLines(reader, controller) {\n  let segment = \"\";\n  while (true) {\n    const { value: chunk, done } = await reader.read();\n    if (done) {\n      break;\n    }\n    segment += utf8Decoder.decode(chunk, { stream: true });\n    const linesArray = segment.split(/\\r\\n|\\n|\\r/g);\n    segment = linesArray.pop() || \"\";\n    await processLines(linesArray, controller);\n  }\n  if (segment) {\n    const linesArray = [segment];\n    await processLines(linesArray, controller);\n  }\n  controller.close();\n}\nfunction createParser2(res) {\n  var _a;\n  const reader = (_a = res.body) == null ? void 0 : _a.getReader();\n  return new ReadableStream({\n    async start(controller) {\n      if (!reader) {\n        controller.close();\n        return;\n      }\n      await readAndProcessLines(reader, controller);\n    }\n  });\n}\nasync function* streamable2(stream) {\n  for await (const chunk of stream) {\n    if (chunk.eventType === \"text-generation\") {\n      const text = chunk.text;\n      if (text)\n        yield text;\n    }\n  }\n}\nfunction CohereStream(reader, callbacks) {\n  if (Symbol.asyncIterator in reader) {\n    return readableFromAsyncIterable(streamable2(reader)).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n  } else {\n    return createParser2(reader).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n  }\n}\n\n// streams/google-generative-ai-stream.ts\nasync function* streamable3(response) {\n  var _a, _b, _c;\n  for await (const chunk of response.stream) {\n    const parts = (_c = (_b = (_a = chunk.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts;\n    if (parts === void 0) {\n      continue;\n    }\n    const firstPart = parts[0];\n    if (typeof firstPart.text === \"string\") {\n      yield firstPart.text;\n    }\n  }\n}\nfunction GoogleGenerativeAIStream(response, cb) {\n  return readableFromAsyncIterable(streamable3(response)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/huggingface-stream.ts\nfunction createParser3(res) {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  return new ReadableStream({\n    async pull(controller) {\n      var _a, _b;\n      const { value, done } = await res.next();\n      if (done) {\n        controller.close();\n        return;\n      }\n      const text = trimStartOfStream((_b = (_a = value.token) == null ? void 0 : _a.text) != null ? _b : \"\");\n      if (!text)\n        return;\n      if (value.generated_text != null && value.generated_text.length > 0) {\n        return;\n      }\n      if (text === \"</s>\" || text === \"<|endoftext|>\" || text === \"<|end|>\") {\n        return;\n      }\n      controller.enqueue(text);\n    }\n  });\n}\nfunction HuggingFaceStream(res, callbacks) {\n  return createParser3(res).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/inkeep-stream.ts\nfunction InkeepStream(res, callbacks) {\n  if (!res.body) {\n    throw new Error(\"Response body is null\");\n  }\n  let chat_session_id = \"\";\n  let records_cited;\n  const inkeepEventParser = (data, options) => {\n    var _a, _b;\n    const { event } = options;\n    if (event === \"records_cited\") {\n      records_cited = JSON.parse(data);\n      (_a = callbacks == null ? void 0 : callbacks.onRecordsCited) == null ? void 0 : _a.call(callbacks, records_cited);\n    }\n    if (event === \"message_chunk\") {\n      const inkeepMessageChunk = JSON.parse(data);\n      chat_session_id = (_b = inkeepMessageChunk.chat_session_id) != null ? _b : chat_session_id;\n      return inkeepMessageChunk.content_chunk;\n    }\n    return;\n  };\n  let { onRecordsCited, ...passThroughCallbacks } = callbacks || {};\n  passThroughCallbacks = {\n    ...passThroughCallbacks,\n    onFinal: (completion) => {\n      var _a;\n      const inkeepOnFinalMetadata = {\n        chat_session_id,\n        records_cited\n      };\n      (_a = callbacks == null ? void 0 : callbacks.onFinal) == null ? void 0 : _a.call(callbacks, completion, inkeepOnFinalMetadata);\n    }\n  };\n  return AIStream(res, inkeepEventParser, passThroughCallbacks).pipeThrough(\n    createStreamDataTransformer()\n  );\n}\n\n// streams/langchain-adapter.ts\nvar langchain_adapter_exports = {};\n__export(langchain_adapter_exports, {\n  toAIStream: () => toAIStream\n});\nfunction toAIStream(stream, callbacks) {\n  return stream.pipeThrough(\n    new TransformStream({\n      transform: async (chunk, controller) => {\n        if (typeof chunk === \"string\") {\n          controller.enqueue(chunk);\n        } else if (typeof chunk.content === \"string\") {\n          controller.enqueue(chunk.content);\n        } else {\n          const content = chunk.content;\n          for (const item of content) {\n            if (item.type === \"text\") {\n              controller.enqueue(item.text);\n            }\n          }\n        }\n      }\n    })\n  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/langchain-stream.ts\nfunction LangChainStream(callbacks) {\n  const stream = new TransformStream();\n  const writer = stream.writable.getWriter();\n  const runs = /* @__PURE__ */ new Set();\n  const handleError = async (e, runId) => {\n    runs.delete(runId);\n    await writer.ready;\n    await writer.abort(e);\n  };\n  const handleStart = async (runId) => {\n    runs.add(runId);\n  };\n  const handleEnd = async (runId) => {\n    runs.delete(runId);\n    if (runs.size === 0) {\n      await writer.ready;\n      await writer.close();\n    }\n  };\n  return {\n    stream: stream.readable.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer()),\n    writer,\n    handlers: {\n      handleLLMNewToken: async (token) => {\n        await writer.ready;\n        await writer.write(token);\n      },\n      handleLLMStart: async (_llm, _prompts, runId) => {\n        handleStart(runId);\n      },\n      handleLLMEnd: async (_output, runId) => {\n        await handleEnd(runId);\n      },\n      handleLLMError: async (e, runId) => {\n        await handleError(e, runId);\n      },\n      handleChainStart: async (_chain, _inputs, runId) => {\n        handleStart(runId);\n      },\n      handleChainEnd: async (_outputs, runId) => {\n        await handleEnd(runId);\n      },\n      handleChainError: async (e, runId) => {\n        await handleError(e, runId);\n      },\n      handleToolStart: async (_tool, _input, runId) => {\n        handleStart(runId);\n      },\n      handleToolEnd: async (_output, runId) => {\n        await handleEnd(runId);\n      },\n      handleToolError: async (e, runId) => {\n        await handleError(e, runId);\n      }\n    }\n  };\n}\n\n// streams/mistral-stream.ts\nasync function* streamable4(stream) {\n  var _a, _b;\n  for await (const chunk of stream) {\n    const content = (_b = (_a = chunk.choices[0]) == null ? void 0 : _a.delta) == null ? void 0 : _b.content;\n    if (content === void 0 || content === \"\") {\n      continue;\n    }\n    yield content;\n  }\n}\nfunction MistralStream(response, callbacks) {\n  const stream = readableFromAsyncIterable(streamable4(response));\n  return stream.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/openai-stream.ts\n\nfunction parseOpenAIStream() {\n  const extract = chunkToText();\n  return (data) => extract(JSON.parse(data));\n}\nasync function* streamable5(stream) {\n  const extract = chunkToText();\n  for await (let chunk of stream) {\n    if (\"promptFilterResults\" in chunk) {\n      chunk = {\n        id: chunk.id,\n        created: chunk.created.getDate(),\n        object: chunk.object,\n        // not exposed by Azure API\n        model: chunk.model,\n        // not exposed by Azure API\n        choices: chunk.choices.map((choice) => {\n          var _a, _b, _c, _d, _e, _f, _g;\n          return {\n            delta: {\n              content: (_a = choice.delta) == null ? void 0 : _a.content,\n              function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n              role: (_c = choice.delta) == null ? void 0 : _c.role,\n              tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index) => ({\n                index,\n                id: toolCall.id,\n                function: toolCall.function,\n                type: toolCall.type\n              })) : void 0\n            },\n            finish_reason: choice.finishReason,\n            index: choice.index\n          };\n        })\n      };\n    }\n    const text = extract(chunk);\n    if (text)\n      yield text;\n  }\n}\nfunction chunkToText() {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  let isFunctionStreamingIn;\n  return (json) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n    if (isChatCompletionChunk(json)) {\n      const delta = (_a = json.choices[0]) == null ? void 0 : _a.delta;\n      if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n        isFunctionStreamingIn = true;\n        return {\n          isText: false,\n          content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n        };\n      } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n        isFunctionStreamingIn = true;\n        const toolCall = delta.tool_calls[0];\n        if (toolCall.index === 0) {\n          return {\n            isText: false,\n            content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n          };\n        } else {\n          return {\n            isText: false,\n            content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n          };\n        }\n      } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n        return {\n          isText: false,\n          content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n        };\n      } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n        return {\n          isText: false,\n          content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n        };\n      } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n        isFunctionStreamingIn = false;\n        return {\n          isText: false,\n          content: '\"}}'\n        };\n      } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n        isFunctionStreamingIn = false;\n        return {\n          isText: false,\n          content: '\"}}]}'\n        };\n      }\n    }\n    const text = trimStartOfStream(\n      isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\"\n    );\n    return text;\n  };\n  function cleanupArguments(argumentChunk) {\n    let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n    return `${escapedPartialJson}`;\n  }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\n  \"internal_openai_fn_messages\"\n);\nfunction isChatCompletionChunk(data) {\n  return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n  return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n  const cb = callbacks;\n  let stream;\n  if (Symbol.asyncIterator in res) {\n    stream = readableFromAsyncIterable(streamable5(res)).pipeThrough(\n      createCallbacksTransformer(\n        (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n          ...cb,\n          onFinal: void 0\n        } : {\n          ...cb\n        }\n      )\n    );\n  } else {\n    stream = AIStream(\n      res,\n      parseOpenAIStream(),\n      (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n        ...cb,\n        onFinal: void 0\n      } : {\n        ...cb\n      }\n    );\n  }\n  if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n    const functionCallTransformer = createFunctionCallTransformer(cb);\n    return stream.pipeThrough(functionCallTransformer);\n  } else {\n    return stream.pipeThrough(createStreamDataTransformer());\n  }\n}\nfunction createFunctionCallTransformer(callbacks) {\n  const textEncoder = new TextEncoder();\n  let isFirstChunk = true;\n  let aggregatedResponse = \"\";\n  let aggregatedFinalCompletionResponse = \"\";\n  let isFunctionStreamingIn = false;\n  let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n  const decode = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.createChunkDecoder)();\n  return new TransformStream({\n    async transform(chunk, controller) {\n      const message = decode(chunk);\n      aggregatedFinalCompletionResponse += message;\n      const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n      if (shouldHandleAsFunction) {\n        isFunctionStreamingIn = true;\n        aggregatedResponse += message;\n        isFirstChunk = false;\n        return;\n      }\n      if (!isFunctionStreamingIn) {\n        controller.enqueue(\n          textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"text\", message))\n        );\n        return;\n      } else {\n        aggregatedResponse += message;\n      }\n    },\n    async flush(controller) {\n      try {\n        if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n          isFunctionStreamingIn = false;\n          const payload = JSON.parse(aggregatedResponse);\n          let newFunctionCallMessages = [\n            ...functionCallMessages\n          ];\n          let functionResponse = void 0;\n          if (callbacks.experimental_onFunctionCall) {\n            if (payload.function_call === void 0) {\n              console.warn(\n                \"experimental_onFunctionCall should not be defined when using tools\"\n              );\n            }\n            const argumentsPayload = JSON.parse(\n              payload.function_call.arguments\n            );\n            functionResponse = await callbacks.experimental_onFunctionCall(\n              {\n                name: payload.function_call.name,\n                arguments: argumentsPayload\n              },\n              (result) => {\n                newFunctionCallMessages = [\n                  ...functionCallMessages,\n                  {\n                    role: \"assistant\",\n                    content: \"\",\n                    function_call: payload.function_call\n                  },\n                  {\n                    role: \"function\",\n                    name: payload.function_call.name,\n                    content: JSON.stringify(result)\n                  }\n                ];\n                return newFunctionCallMessages;\n              }\n            );\n          }\n          if (callbacks.experimental_onToolCall) {\n            const toolCalls = {\n              tools: []\n            };\n            for (const tool2 of payload.tool_calls) {\n              toolCalls.tools.push({\n                id: tool2.id,\n                type: \"function\",\n                func: {\n                  name: tool2.function.name,\n                  arguments: JSON.parse(tool2.function.arguments)\n                }\n              });\n            }\n            let responseIndex = 0;\n            try {\n              functionResponse = await callbacks.experimental_onToolCall(\n                toolCalls,\n                (result) => {\n                  if (result) {\n                    const { tool_call_id, function_name, tool_call_result } = result;\n                    newFunctionCallMessages = [\n                      ...newFunctionCallMessages,\n                      // Only append the assistant message if it's the first response\n                      ...responseIndex === 0 ? [\n                        {\n                          role: \"assistant\",\n                          content: \"\",\n                          tool_calls: payload.tool_calls.map(\n                            (tc) => ({\n                              id: tc.id,\n                              type: \"function\",\n                              function: {\n                                name: tc.function.name,\n                                // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                arguments: JSON.stringify(\n                                  tc.function.arguments\n                                )\n                              }\n                            })\n                          )\n                        }\n                      ] : [],\n                      // Append the function call result message\n                      {\n                        role: \"tool\",\n                        tool_call_id,\n                        name: function_name,\n                        content: JSON.stringify(tool_call_result)\n                      }\n                    ];\n                    responseIndex++;\n                  }\n                  return newFunctionCallMessages;\n                }\n              );\n            } catch (e) {\n              console.error(\"Error calling experimental_onToolCall:\", e);\n            }\n          }\n          if (!functionResponse) {\n            controller.enqueue(\n              textEncoder.encode(\n                (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\n                  payload.function_call ? \"function_call\" : \"tool_calls\",\n                  // parse to prevent double-encoding:\n                  JSON.parse(aggregatedResponse)\n                )\n              )\n            );\n            return;\n          } else if (typeof functionResponse === \"string\") {\n            controller.enqueue(\n              textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_3__.formatStreamPart)(\"text\", functionResponse))\n            );\n            aggregatedFinalCompletionResponse = functionResponse;\n            return;\n          }\n          const filteredCallbacks = {\n            ...callbacks,\n            onStart: void 0\n          };\n          callbacks.onFinal = void 0;\n          const openAIStream = OpenAIStream(functionResponse, {\n            ...filteredCallbacks,\n            [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n          });\n          const reader = openAIStream.getReader();\n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) {\n              break;\n            }\n            controller.enqueue(value);\n          }\n        }\n      } finally {\n        if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n          await callbacks.onFinal(aggregatedFinalCompletionResponse);\n        }\n      }\n    }\n  });\n}\n\n// streams/replicate-stream.ts\nasync function ReplicateStream(res, cb, options) {\n  var _a;\n  const url = (_a = res.urls) == null ? void 0 : _a.stream;\n  if (!url) {\n    if (res.error)\n      throw new Error(res.error);\n    else\n      throw new Error(\"Missing stream URL in Replicate response\");\n  }\n  const eventStream = await fetch(url, {\n    method: \"GET\",\n    headers: {\n      Accept: \"text/event-stream\",\n      ...options == null ? void 0 : options.headers\n    }\n  });\n  return AIStream(eventStream, void 0, cb).pipeThrough(\n    createStreamDataTransformer()\n  );\n}\n\n// core/util/merge-streams.ts\nfunction mergeStreams(stream1, stream2) {\n  const reader1 = stream1.getReader();\n  const reader2 = stream2.getReader();\n  let lastRead1 = void 0;\n  let lastRead2 = void 0;\n  let stream1Done = false;\n  let stream2Done = false;\n  async function readStream1(controller) {\n    try {\n      if (lastRead1 == null) {\n        lastRead1 = reader1.read();\n      }\n      const result = await lastRead1;\n      lastRead1 = void 0;\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n  async function readStream2(controller) {\n    try {\n      if (lastRead2 == null) {\n        lastRead2 = reader2.read();\n      }\n      const result = await lastRead2;\n      lastRead2 = void 0;\n      if (!result.done) {\n        controller.enqueue(result.value);\n      } else {\n        controller.close();\n      }\n    } catch (error) {\n      controller.error(error);\n    }\n  }\n  return new ReadableStream({\n    async pull(controller) {\n      try {\n        if (stream1Done) {\n          readStream2(controller);\n          return;\n        }\n        if (stream2Done) {\n          readStream1(controller);\n          return;\n        }\n        if (lastRead1 == null) {\n          lastRead1 = reader1.read();\n        }\n        if (lastRead2 == null) {\n          lastRead2 = reader2.read();\n        }\n        const { result, reader } = await Promise.race([\n          lastRead1.then((result2) => ({ result: result2, reader: reader1 })),\n          lastRead2.then((result2) => ({ result: result2, reader: reader2 }))\n        ]);\n        if (!result.done) {\n          controller.enqueue(result.value);\n        }\n        if (reader === reader1) {\n          lastRead1 = void 0;\n          if (result.done) {\n            readStream2(controller);\n            stream1Done = true;\n          }\n        } else {\n          lastRead2 = void 0;\n          if (result.done) {\n            stream2Done = true;\n            readStream1(controller);\n          }\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    cancel() {\n      reader1.cancel();\n      reader2.cancel();\n    }\n  });\n}\n\n// streams/stream-to-response.ts\nfunction streamToResponse(res, response, init, data) {\n  var _a;\n  response.writeHead((_a = init == null ? void 0 : init.status) != null ? _a : 200, {\n    \"Content-Type\": \"text/plain; charset=utf-8\",\n    ...init == null ? void 0 : init.headers\n  });\n  let processedStream = res;\n  if (data) {\n    processedStream = mergeStreams(data.stream, res);\n  }\n  const reader = processedStream.getReader();\n  function read() {\n    reader.read().then(({ done, value }) => {\n      if (done) {\n        response.end();\n        return;\n      }\n      response.write(value);\n      read();\n    });\n  }\n  read();\n}\n\n// streams/streaming-text-response.ts\nvar StreamingTextResponse = class extends Response {\n  constructor(res, init, data) {\n    let processedStream = res;\n    if (data) {\n      processedStream = mergeStreams(data.stream, res);\n    }\n    super(processedStream, {\n      ...init,\n      status: 200,\n      headers: prepareResponseHeaders(init, {\n        contentType: \"text/plain; charset=utf-8\"\n      })\n    });\n  }\n};\n\n// streams/index.ts\nvar generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId;\nvar nanoid = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.generateId;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTs7QUFFQTtBQU0wQjtBQUM0Qzs7QUFFdEU7QUFDNEQ7QUFDVzs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsSUFBSTtBQUNKLFFBQVEsb0VBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1RUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQVU7QUFDMUIsaUNBQWlDLFdBQVcsd0JBQXdCLGFBQWE7QUFDakY7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGtDQUFrQywwREFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxVQUFVLGlFQUFpRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdEQUFVO0FBQ3hCLCtCQUErQixXQUFXLHNDQUFzQyxhQUFhO0FBQzdGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBOEMsWUFBWTtBQUMxRDtBQUNBLDBCQUEwQix1Q0FBdUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMENBQTBDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUkwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7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b3VyY2VzIjpbIndlYnBhY2s6Ly9jaGF0LWFpLy4vbm9kZV9tb2R1bGVzL2FpL2Rpc3QvaW5kZXgubWpzP2RjYzQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3RyZWFtcy9pbmRleC50c1xuaW1wb3J0IHtcbiAgZm9ybWF0U3RyZWFtUGFydCxcbiAgcGFyc2VTdHJlYW1QYXJ0LFxuICByZWFkRGF0YVN0cmVhbSxcbiAgcGFyc2VDb21wbGV4UmVzcG9uc2Vcbn0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmltcG9ydCB7IGdlbmVyYXRlSWQgYXMgZ2VuZXJhdGVJZEltcGwgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBjb3JlL3V0aWwvcmV0cnktd2l0aC1leHBvbmVudGlhbC1iYWNrb2ZmLnRzXG5pbXBvcnQgeyBBUElDYWxsRXJyb3IsIFJldHJ5RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgZ2V0RXJyb3JNZXNzYWdlLCBpc0Fib3J0RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBjb3JlL3V0aWwvZGVsYXkudHNcbmFzeW5jIGZ1bmN0aW9uIGRlbGF5KGRlbGF5SW5Ncykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXlJbk1zKSk7XG59XG5cbi8vIGNvcmUvdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYudHNcbnZhciByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYgPSAoe1xuICBtYXhSZXRyaWVzID0gMixcbiAgaW5pdGlhbERlbGF5SW5NcyA9IDJlMyxcbiAgYmFja29mZkZhY3RvciA9IDJcbn0gPSB7fSkgPT4gYXN5bmMgKGYpID0+IF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICBtYXhSZXRyaWVzLFxuICBkZWxheUluTXM6IGluaXRpYWxEZWxheUluTXMsXG4gIGJhY2tvZmZGYWN0b3Jcbn0pO1xuYXN5bmMgZnVuY3Rpb24gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihmLCB7XG4gIG1heFJldHJpZXMsXG4gIGRlbGF5SW5NcyxcbiAgYmFja29mZkZhY3RvclxufSwgZXJyb3JzID0gW10pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZigpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKG1heFJldHJpZXMgPT09IDApIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpO1xuICAgIGNvbnN0IG5ld0Vycm9ycyA9IFsuLi5lcnJvcnMsIGVycm9yXTtcbiAgICBjb25zdCB0cnlOdW1iZXIgPSBuZXdFcnJvcnMubGVuZ3RoO1xuICAgIGlmICh0cnlOdW1iZXIgPiBtYXhSZXRyaWVzKSB7XG4gICAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzLiBMYXN0IGVycm9yOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgICByZWFzb246IFwibWF4UmV0cmllc0V4Y2VlZGVkXCIsXG4gICAgICAgIGVycm9yczogbmV3RXJyb3JzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgQVBJQ2FsbEVycm9yLmlzQVBJQ2FsbEVycm9yKGVycm9yKSAmJiBlcnJvci5pc1JldHJ5YWJsZSA9PT0gdHJ1ZSAmJiB0cnlOdW1iZXIgPD0gbWF4UmV0cmllcykge1xuICAgICAgYXdhaXQgZGVsYXkoZGVsYXlJbk1zKTtcbiAgICAgIHJldHVybiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKFxuICAgICAgICBmLFxuICAgICAgICB7IG1heFJldHJpZXMsIGRlbGF5SW5NczogYmFja29mZkZhY3RvciAqIGRlbGF5SW5NcywgYmFja29mZkZhY3RvciB9LFxuICAgICAgICBuZXdFcnJvcnNcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0cnlOdW1iZXIgPT09IDEpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgRmFpbGVkIGFmdGVyICR7dHJ5TnVtYmVyfSBhdHRlbXB0cyB3aXRoIG5vbi1yZXRyeWFibGUgZXJyb3I6ICcke2Vycm9yTWVzc2FnZX0nYCxcbiAgICAgIHJlYXNvbjogXCJlcnJvck5vdFJldHJ5YWJsZVwiLFxuICAgICAgZXJyb3JzOiBuZXdFcnJvcnNcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBjb3JlL2VtYmVkL2VtYmVkLnRzXG5hc3luYyBmdW5jdGlvbiBlbWJlZCh7XG4gIG1vZGVsLFxuICB2YWx1ZSxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnNcbn0pIHtcbiAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICBjb25zdCBtb2RlbFJlc3BvbnNlID0gYXdhaXQgcmV0cnkoXG4gICAgKCkgPT4gbW9kZWwuZG9FbWJlZCh7IHZhbHVlczogW3ZhbHVlXSwgYWJvcnRTaWduYWwsIGhlYWRlcnMgfSlcbiAgKTtcbiAgcmV0dXJuIG5ldyBFbWJlZFJlc3VsdCh7XG4gICAgdmFsdWUsXG4gICAgZW1iZWRkaW5nOiBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3NbMF0sXG4gICAgcmF3UmVzcG9uc2U6IG1vZGVsUmVzcG9uc2UucmF3UmVzcG9uc2VcbiAgfSk7XG59XG52YXIgRW1iZWRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB0aGlzLmVtYmVkZGluZyA9IG9wdGlvbnMuZW1iZWRkaW5nO1xuICAgIHRoaXMucmF3UmVzcG9uc2UgPSBvcHRpb25zLnJhd1Jlc3BvbnNlO1xuICB9XG59O1xuXG4vLyBjb3JlL3V0aWwvc3BsaXQtYXJyYXkudHNcbmZ1bmN0aW9uIHNwbGl0QXJyYXkoYXJyYXksIGNodW5rU2l6ZSkge1xuICBpZiAoY2h1bmtTaXplIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaHVua1NpemUgbXVzdCBiZSBncmVhdGVyIHRoYW4gMFwiKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gY2h1bmtTaXplKSB7XG4gICAgcmVzdWx0LnB1c2goYXJyYXkuc2xpY2UoaSwgaSArIGNodW5rU2l6ZSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIGNvcmUvZW1iZWQvZW1iZWQtbWFueS50c1xuYXN5bmMgZnVuY3Rpb24gZW1iZWRNYW55KHtcbiAgbW9kZWwsXG4gIHZhbHVlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnNcbn0pIHtcbiAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICBjb25zdCBtYXhFbWJlZGRpbmdzUGVyQ2FsbCA9IG1vZGVsLm1heEVtYmVkZGluZ3NQZXJDYWxsO1xuICBpZiAobWF4RW1iZWRkaW5nc1BlckNhbGwgPT0gbnVsbCkge1xuICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCByZXRyeShcbiAgICAgICgpID0+IG1vZGVsLmRvRW1iZWQoeyB2YWx1ZXMsIGFib3J0U2lnbmFsLCBoZWFkZXJzIH0pXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IEVtYmVkTWFueVJlc3VsdCh7XG4gICAgICB2YWx1ZXMsXG4gICAgICBlbWJlZGRpbmdzOiBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3NcbiAgICB9KTtcbiAgfVxuICBjb25zdCB2YWx1ZUNodW5rcyA9IHNwbGl0QXJyYXkodmFsdWVzLCBtYXhFbWJlZGRpbmdzUGVyQ2FsbCk7XG4gIGNvbnN0IGVtYmVkZGluZ3MgPSBbXTtcbiAgZm9yIChjb25zdCBjaHVuayBvZiB2YWx1ZUNodW5rcykge1xuICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCByZXRyeShcbiAgICAgICgpID0+IG1vZGVsLmRvRW1iZWQoeyB2YWx1ZXM6IGNodW5rLCBhYm9ydFNpZ25hbCwgaGVhZGVycyB9KVxuICAgICk7XG4gICAgZW1iZWRkaW5ncy5wdXNoKC4uLm1vZGVsUmVzcG9uc2UuZW1iZWRkaW5ncyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBFbWJlZE1hbnlSZXN1bHQoeyB2YWx1ZXMsIGVtYmVkZGluZ3MgfSk7XG59XG52YXIgRW1iZWRNYW55UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcztcbiAgICB0aGlzLmVtYmVkZGluZ3MgPSBvcHRpb25zLmVtYmVkZGluZ3M7XG4gIH1cbn07XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L2dlbmVyYXRlLW9iamVjdC50c1xuaW1wb3J0IHsgTm9PYmplY3RHZW5lcmF0ZWRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBzYWZlUGFyc2VKU09OIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3Rva2VuLXVzYWdlLnRzXG5mdW5jdGlvbiBjYWxjdWxhdGVUb2tlblVzYWdlKHVzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgcHJvbXB0VG9rZW5zOiB1c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgY29tcGxldGlvblRva2VuczogdXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICB0b3RhbFRva2VuczogdXNhZ2UucHJvbXB0VG9rZW5zICsgdXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICB9O1xufVxuXG4vLyBjb3JlL3V0aWwvZGV0ZWN0LWltYWdlLW1pbWV0eXBlLnRzXG52YXIgbWltZVR5cGVTaWduYXR1cmVzID0gW1xuICB7IG1pbWVUeXBlOiBcImltYWdlL2dpZlwiLCBieXRlczogWzcxLCA3MywgNzBdIH0sXG4gIHsgbWltZVR5cGU6IFwiaW1hZ2UvcG5nXCIsIGJ5dGVzOiBbMTM3LCA4MCwgNzgsIDcxXSB9LFxuICB7IG1pbWVUeXBlOiBcImltYWdlL2pwZWdcIiwgYnl0ZXM6IFsyNTUsIDIxNl0gfSxcbiAgeyBtaW1lVHlwZTogXCJpbWFnZS93ZWJwXCIsIGJ5dGVzOiBbODIsIDczLCA3MCwgNzBdIH1cbl07XG5mdW5jdGlvbiBkZXRlY3RJbWFnZU1pbWVUeXBlKGltYWdlKSB7XG4gIGZvciAoY29uc3QgeyBieXRlcywgbWltZVR5cGUgfSBvZiBtaW1lVHlwZVNpZ25hdHVyZXMpIHtcbiAgICBpZiAoaW1hZ2UubGVuZ3RoID49IGJ5dGVzLmxlbmd0aCAmJiBieXRlcy5ldmVyeSgoYnl0ZSwgaW5kZXgpID0+IGltYWdlW2luZGV4XSA9PT0gYnl0ZSkpIHtcbiAgICAgIHJldHVybiBtaW1lVHlwZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gY29yZS9wcm9tcHQvZGF0YS1jb250ZW50LnRzXG5pbXBvcnQgeyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQge1xuICBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5LFxuICBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5mdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyhjb250ZW50KSB7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChuZXcgVWludDhBcnJheShjb250ZW50KSk7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQoY29udGVudCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoY29udGVudCkge1xuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkoY29udGVudCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBkYXRhIGNvbnRlbnQuIENvbnRlbnQgc3RyaW5nIGlzIG5vdCBhIGJhc2U2NC1lbmNvZGVkIGltYWdlLlwiLFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBjYXVzZTogZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNvbnRlbnQpO1xuICB9XG4gIHRocm93IG5ldyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcih7IGNvbnRlbnQgfSk7XG59XG5cbi8vIGNvcmUvcHJvbXB0L2ludmFsaWQtbWVzc2FnZS1yb2xlLWVycm9yLnRzXG52YXIgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHJvbGUsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIG1lc3NhZ2Ugcm9sZTogJyR7cm9sZX0nLiBNdXN0IGJlIG9uZSBvZjogXCJzeXN0ZW1cIiwgXCJ1c2VyXCIsIFwiYXNzaXN0YW50XCIsIFwidG9vbFwiLmBcbiAgfSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiQUlfSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3JcIjtcbiAgICB0aGlzLnJvbGUgPSByb2xlO1xuICB9XG4gIHN0YXRpYyBpc0ludmFsaWRNZXNzYWdlUm9sZUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gXCJBSV9JbnZhbGlkTWVzc2FnZVJvbGVFcnJvclwiICYmIHR5cGVvZiBlcnJvci5yb2xlID09PSBcInN0cmluZ1wiO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICByb2xlOiB0aGlzLnJvbGVcbiAgICB9O1xuICB9XG59O1xuXG4vLyBjb3JlL3Byb21wdC9jb252ZXJ0LXRvLWxhbmd1YWdlLW1vZGVsLXByb21wdC50c1xuaW1wb3J0IHsgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdChwcm9tcHQpIHtcbiAgY29uc3QgbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzID0gW107XG4gIGlmIChwcm9tcHQuc3lzdGVtICE9IG51bGwpIHtcbiAgICBsYW5ndWFnZU1vZGVsTWVzc2FnZXMucHVzaCh7IHJvbGU6IFwic3lzdGVtXCIsIGNvbnRlbnQ6IHByb21wdC5zeXN0ZW0gfSk7XG4gIH1cbiAgY29uc3QgcHJvbXB0VHlwZSA9IHByb21wdC50eXBlO1xuICBzd2l0Y2ggKHByb21wdFR5cGUpIHtcbiAgICBjYXNlIFwicHJvbXB0XCI6IHtcbiAgICAgIGxhbmd1YWdlTW9kZWxNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBwcm9tcHQucHJvbXB0IH1dXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwibWVzc2FnZXNcIjoge1xuICAgICAgbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzLnB1c2goXG4gICAgICAgIC4uLnByb21wdC5tZXNzYWdlcy5tYXAoY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UpXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBwcm9tcHRUeXBlO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwcm9tcHQgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzO1xufVxuZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UobWVzc2FnZSkge1xuICBjb25zdCByb2xlID0gbWVzc2FnZS5yb2xlO1xuICBzd2l0Y2ggKHJvbGUpIHtcbiAgICBjYXNlIFwic3lzdGVtXCI6IHtcbiAgICAgIHJldHVybiB7IHJvbGU6IFwic3lzdGVtXCIsIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCB9O1xuICAgIH1cbiAgICBjYXNlIFwidXNlclwiOiB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQubWFwKFxuICAgICAgICAgIChwYXJ0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImltYWdlXCI6IHtcbiAgICAgICAgICAgICAgICBpZiAocGFydC5pbWFnZSBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZVwiLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogcGFydC5pbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHBhcnQubWltZVR5cGVcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC5pbWFnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChwYXJ0LmltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh1cmwucHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaHR0cDpcIjpcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaHR0cHM6XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHBhcnQubWltZVR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYXRhOlwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbaGVhZGVyLCBiYXNlNjRDb250ZW50XSA9IHBhcnQuaW1hZ2Uuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtaW1lVHlwZSA9IGhlYWRlci5zcGxpdChcIjtcIilbMF0uc3BsaXQoXCI6XCIpWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWltZVR5cGUgPT0gbnVsbCB8fCBiYXNlNjRDb250ZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGJhc2U2NENvbnRlbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYEVycm9yIHByb2Nlc3NpbmcgZGF0YSBVUkw6ICR7Z2V0RXJyb3JNZXNzYWdlMihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBgVW5zdXBwb3J0ZWQgVVJMIHByb3RvY29sOiAke3VybC5wcm90b2NvbH1gXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoX2lnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VVaW50OCA9IGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShwYXJ0LmltYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZVwiLFxuICAgICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlVWludDgsXG4gICAgICAgICAgICAgICAgICBtaW1lVHlwZTogKF9hID0gcGFydC5taW1lVHlwZSkgIT0gbnVsbCA/IF9hIDogZGV0ZWN0SW1hZ2VNaW1lVHlwZShpbWFnZVVpbnQ4KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5maWx0ZXIoXG4gICAgICAgICAgLy8gcmVtb3ZlIGVtcHR5IHRleHQgcGFydHM6XG4gICAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSAhPT0gXCJ0ZXh0XCIgfHwgcGFydC50ZXh0ICE9PSBcIlwiXG4gICAgICAgIClcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcm9sZTtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcih7IHJvbGU6IF9leGhhdXN0aXZlQ2hlY2sgfSk7XG4gICAgfVxuICB9XG59XG5cbi8vIGNvcmUvcHJvbXB0L2dldC12YWxpZGF0ZWQtcHJvbXB0LnRzXG5pbXBvcnQgeyBJbnZhbGlkUHJvbXB0RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gZ2V0VmFsaWRhdGVkUHJvbXB0KHByb21wdCkge1xuICBpZiAocHJvbXB0LnByb21wdCA9PSBudWxsICYmIHByb21wdC5tZXNzYWdlcyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInByb21wdCBvciBtZXNzYWdlcyBtdXN0IGJlIGRlZmluZWRcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IGFuZCBtZXNzYWdlcyBjYW5ub3QgYmUgZGVmaW5lZCBhdCB0aGUgc2FtZSB0aW1lXCJcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcHJvbXB0LnByb21wdCAhPSBudWxsID8ge1xuICAgIHR5cGU6IFwicHJvbXB0XCIsXG4gICAgcHJvbXB0OiBwcm9tcHQucHJvbXB0LFxuICAgIG1lc3NhZ2VzOiB2b2lkIDAsXG4gICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtXG4gIH0gOiB7XG4gICAgdHlwZTogXCJtZXNzYWdlc1wiLFxuICAgIHByb21wdDogdm9pZCAwLFxuICAgIG1lc3NhZ2VzOiBwcm9tcHQubWVzc2FnZXMsXG4gICAgLy8gb25seSBwb3NzaWJsZSBjYXNlIGJjIG9mIGNoZWNrcyBhYm92ZVxuICAgIHN5c3RlbTogcHJvbXB0LnN5c3RlbVxuICB9O1xufVxuXG4vLyBjb3JlL3Byb21wdC9wcmVwYXJlLWNhbGwtc2V0dGluZ3MudHNcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIHByZXBhcmVDYWxsU2V0dGluZ3Moe1xuICBtYXhUb2tlbnMsXG4gIHRlbXBlcmF0dXJlLFxuICB0b3BQLFxuICBwcmVzZW5jZVBlbmFsdHksXG4gIGZyZXF1ZW5jeVBlbmFsdHksXG4gIHNlZWQsXG4gIG1heFJldHJpZXNcbn0pIHtcbiAgaWYgKG1heFRva2VucyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFRva2VucykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhUb2tlbnNcIixcbiAgICAgICAgdmFsdWU6IG1heFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhUb2tlbnMgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWF4VG9rZW5zIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFRva2Vuc1wiLFxuICAgICAgICB2YWx1ZTogbWF4VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFRva2VucyBtdXN0IGJlID49IDFcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh0ZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wZXJhdHVyZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRlbXBlcmF0dXJlXCIsXG4gICAgICAgIHZhbHVlOiB0ZW1wZXJhdHVyZSxcbiAgICAgICAgbWVzc2FnZTogXCJ0ZW1wZXJhdHVyZSBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodG9wUCAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0b3BQICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidG9wUFwiLFxuICAgICAgICB2YWx1ZTogdG9wUCxcbiAgICAgICAgbWVzc2FnZTogXCJ0b3BQIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChwcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcHJlc2VuY2VQZW5hbHR5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwicHJlc2VuY2VQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBwcmVzZW5jZVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6IFwicHJlc2VuY2VQZW5hbHR5IG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChmcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGZyZXF1ZW5jeVBlbmFsdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJmcmVxdWVuY3lQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBmcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiBcImZyZXF1ZW5jeVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHNlZWQgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzZWVkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNlZWRcIixcbiAgICAgICAgdmFsdWU6IHNlZWQsXG4gICAgICAgIG1lc3NhZ2U6IFwic2VlZCBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChtYXhSZXRyaWVzICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4UmV0cmllcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhSZXRyaWVzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFJldHJpZXMgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWF4UmV0cmllcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhSZXRyaWVzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFJldHJpZXMgbXVzdCBiZSA+PSAwXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG1heFRva2VucyxcbiAgICB0ZW1wZXJhdHVyZTogdGVtcGVyYXR1cmUgIT0gbnVsbCA/IHRlbXBlcmF0dXJlIDogMCxcbiAgICB0b3BQLFxuICAgIHByZXNlbmNlUGVuYWx0eSxcbiAgICBmcmVxdWVuY3lQZW5hbHR5LFxuICAgIHNlZWQsXG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllcyAhPSBudWxsID8gbWF4UmV0cmllcyA6IDJcbiAgfTtcbn1cblxuLy8gY29yZS91dGlsL2NvbnZlcnQtem9kLXRvLWpzb24tc2NoZW1hLnRzXG5pbXBvcnQgem9kVG9Kc29uU2NoZW1hIGZyb20gXCJ6b2QtdG8tanNvbi1zY2hlbWFcIjtcbmZ1bmN0aW9uIGNvbnZlcnRab2RUb0pTT05TY2hlbWEoem9kU2NoZW1hKSB7XG4gIHJldHVybiB6b2RUb0pzb25TY2hlbWEoem9kU2NoZW1hKTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvaW5qZWN0LWpzb24tc2NoZW1hLWludG8tc3lzdGVtLnRzXG52YXIgREVGQVVMVF9TQ0hFTUFfUFJFRklYID0gXCJKU09OIHNjaGVtYTpcIjtcbnZhciBERUZBVUxUX1NDSEVNQV9TVUZGSVggPSBcIllvdSBNVVNUIGFuc3dlciB3aXRoIGEgSlNPTiBvYmplY3QgdGhhdCBtYXRjaGVzIHRoZSBKU09OIHNjaGVtYSBhYm92ZS5cIjtcbmZ1bmN0aW9uIGluamVjdEpzb25TY2hlbWFJbnRvU3lzdGVtKHtcbiAgc3lzdGVtLFxuICBzY2hlbWEsXG4gIHNjaGVtYVByZWZpeCA9IERFRkFVTFRfU0NIRU1BX1BSRUZJWCxcbiAgc2NoZW1hU3VmZml4ID0gREVGQVVMVF9TQ0hFTUFfU1VGRklYXG59KSB7XG4gIHJldHVybiBbXG4gICAgc3lzdGVtLFxuICAgIHN5c3RlbSAhPSBudWxsID8gXCJcIiA6IG51bGwsXG4gICAgLy8gYWRkIGEgbmV3bGluZSBpZiBzeXN0ZW0gaXMgbm90IG51bGxcbiAgICBzY2hlbWFQcmVmaXgsXG4gICAgSlNPTi5zdHJpbmdpZnkoc2NoZW1hKSxcbiAgICBzY2hlbWFTdWZmaXhcbiAgXS5maWx0ZXIoKGxpbmUpID0+IGxpbmUgIT0gbnVsbCkuam9pbihcIlxcblwiKTtcbn1cblxuLy8gY29yZS91dGlsL3ByZXBhcmUtcmVzcG9uc2UtaGVhZGVycy50c1xuZnVuY3Rpb24gcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7IGNvbnRlbnRUeXBlIH0pIHtcbiAgdmFyIF9hO1xuICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKF9hID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzKSAhPSBudWxsID8gX2EgOiB7fSk7XG4gIGlmICghaGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBjb250ZW50VHlwZSk7XG4gIH1cbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L2dlbmVyYXRlLW9iamVjdC50c1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVPYmplY3Qoe1xuICBtb2RlbCxcbiAgc2NoZW1hLFxuICBtb2RlLFxuICBzeXN0ZW0sXG4gIHByb21wdCxcbiAgbWVzc2FnZXMsXG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICAuLi5zZXR0aW5nc1xufSkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gIGNvbnN0IGpzb25TY2hlbWEgPSBjb252ZXJ0Wm9kVG9KU09OU2NoZW1hKHNjaGVtYSk7XG4gIGlmIChtb2RlID09PSBcImF1dG9cIiB8fCBtb2RlID09IG51bGwpIHtcbiAgICBtb2RlID0gbW9kZWwuZGVmYXVsdE9iamVjdEdlbmVyYXRpb25Nb2RlO1xuICB9XG4gIGxldCByZXN1bHQ7XG4gIGxldCBmaW5pc2hSZWFzb247XG4gIGxldCB1c2FnZTtcbiAgbGV0IHdhcm5pbmdzO1xuICBsZXQgcmF3UmVzcG9uc2U7XG4gIGxldCBsb2dwcm9icztcbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSBcImpzb25cIjoge1xuICAgICAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gZ2V0VmFsaWRhdGVkUHJvbXB0KHtcbiAgICAgICAgc3lzdGVtOiBpbmplY3RKc29uU2NoZW1hSW50b1N5c3RlbSh7IHN5c3RlbSwgc2NoZW1hOiBqc29uU2NoZW1hIH0pLFxuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2VzXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGdlbmVyYXRlUmVzdWx0ID0gYXdhaXQgcmV0cnkoKCkgPT4ge1xuICAgICAgICByZXR1cm4gbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgbW9kZTogeyB0eXBlOiBcIm9iamVjdC1qc29uXCIgfSxcbiAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICBpbnB1dEZvcm1hdDogdmFsaWRhdGVkUHJvbXB0LnR5cGUsXG4gICAgICAgICAgcHJvbXB0OiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHZhbGlkYXRlZFByb21wdCksXG4gICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgaGVhZGVyc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGdlbmVyYXRlUmVzdWx0LnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVSZXN1bHQudGV4dDtcbiAgICAgIGZpbmlzaFJlYXNvbiA9IGdlbmVyYXRlUmVzdWx0LmZpbmlzaFJlYXNvbjtcbiAgICAgIHVzYWdlID0gZ2VuZXJhdGVSZXN1bHQudXNhZ2U7XG4gICAgICB3YXJuaW5ncyA9IGdlbmVyYXRlUmVzdWx0Lndhcm5pbmdzO1xuICAgICAgcmF3UmVzcG9uc2UgPSBnZW5lcmF0ZVJlc3VsdC5yYXdSZXNwb25zZTtcbiAgICAgIGxvZ3Byb2JzID0gZ2VuZXJhdGVSZXN1bHQubG9ncHJvYnM7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImdyYW1tYXJcIjoge1xuICAgICAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gZ2V0VmFsaWRhdGVkUHJvbXB0KHtcbiAgICAgICAgc3lzdGVtOiBpbmplY3RKc29uU2NoZW1hSW50b1N5c3RlbSh7IHN5c3RlbSwgc2NoZW1hOiBqc29uU2NoZW1hIH0pLFxuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2VzXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGdlbmVyYXRlUmVzdWx0ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICgpID0+IG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICAgIG1vZGU6IHsgdHlwZTogXCJvYmplY3QtZ3JhbW1hclwiLCBzY2hlbWE6IGpzb25TY2hlbWEgfSxcbiAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICBpbnB1dEZvcm1hdDogdmFsaWRhdGVkUHJvbXB0LnR5cGUsXG4gICAgICAgICAgcHJvbXB0OiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHZhbGlkYXRlZFByb21wdCksXG4gICAgICAgICAgYWJvcnRTaWduYWxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBpZiAoZ2VuZXJhdGVSZXN1bHQudGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKCk7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBnZW5lcmF0ZVJlc3VsdC50ZXh0O1xuICAgICAgZmluaXNoUmVhc29uID0gZ2VuZXJhdGVSZXN1bHQuZmluaXNoUmVhc29uO1xuICAgICAgdXNhZ2UgPSBnZW5lcmF0ZVJlc3VsdC51c2FnZTtcbiAgICAgIHdhcm5pbmdzID0gZ2VuZXJhdGVSZXN1bHQud2FybmluZ3M7XG4gICAgICByYXdSZXNwb25zZSA9IGdlbmVyYXRlUmVzdWx0LnJhd1Jlc3BvbnNlO1xuICAgICAgbG9ncHJvYnMgPSBnZW5lcmF0ZVJlc3VsdC5sb2dwcm9icztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICBjb25zdCB2YWxpZGF0ZWRQcm9tcHQgPSBnZXRWYWxpZGF0ZWRQcm9tcHQoe1xuICAgICAgICBzeXN0ZW0sXG4gICAgICAgIHByb21wdCxcbiAgICAgICAgbWVzc2FnZXNcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZ2VuZXJhdGVSZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAgICAgKCkgPT4gbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgbW9kZToge1xuICAgICAgICAgICAgdHlwZTogXCJvYmplY3QtdG9vbFwiLFxuICAgICAgICAgICAgdG9vbDoge1xuICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgIG5hbWU6IFwianNvblwiLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJSZXNwb25kIHdpdGggYSBKU09OIG9iamVjdC5cIixcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczoganNvblNjaGVtYVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgaW5wdXRGb3JtYXQ6IHZhbGlkYXRlZFByb21wdC50eXBlLFxuICAgICAgICAgIHByb21wdDogY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh2YWxpZGF0ZWRQcm9tcHQpLFxuICAgICAgICAgIGFib3J0U2lnbmFsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgY29uc3QgZnVuY3Rpb25BcmdzID0gKF9iID0gKF9hID0gZ2VuZXJhdGVSZXN1bHQudG9vbENhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2FbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5hcmdzO1xuICAgICAgaWYgKGZ1bmN0aW9uQXJncyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKCk7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmdW5jdGlvbkFyZ3M7XG4gICAgICBmaW5pc2hSZWFzb24gPSBnZW5lcmF0ZVJlc3VsdC5maW5pc2hSZWFzb247XG4gICAgICB1c2FnZSA9IGdlbmVyYXRlUmVzdWx0LnVzYWdlO1xuICAgICAgd2FybmluZ3MgPSBnZW5lcmF0ZVJlc3VsdC53YXJuaW5ncztcbiAgICAgIHJhd1Jlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmF3UmVzcG9uc2U7XG4gICAgICBsb2dwcm9icyA9IGdlbmVyYXRlUmVzdWx0LmxvZ3Byb2JzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2Ugdm9pZCAwOiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbCBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCBvYmplY3QgZ2VuZXJhdGlvbiBtb2RlLlwiKTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG1vZGU7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG1vZGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcGFyc2VSZXN1bHQgPSBzYWZlUGFyc2VKU09OKHsgdGV4dDogcmVzdWx0LCBzY2hlbWEgfSk7XG4gIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgIHRocm93IHBhcnNlUmVzdWx0LmVycm9yO1xuICB9XG4gIHJldHVybiBuZXcgR2VuZXJhdGVPYmplY3RSZXN1bHQoe1xuICAgIG9iamVjdDogcGFyc2VSZXN1bHQudmFsdWUsXG4gICAgZmluaXNoUmVhc29uLFxuICAgIHVzYWdlOiBjYWxjdWxhdGVUb2tlblVzYWdlKHVzYWdlKSxcbiAgICB3YXJuaW5ncyxcbiAgICByYXdSZXNwb25zZSxcbiAgICBsb2dwcm9ic1xuICB9KTtcbn1cbnZhciBHZW5lcmF0ZU9iamVjdFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub2JqZWN0ID0gb3B0aW9ucy5vYmplY3Q7XG4gICAgdGhpcy5maW5pc2hSZWFzb24gPSBvcHRpb25zLmZpbmlzaFJlYXNvbjtcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLnJhd1Jlc3BvbnNlID0gb3B0aW9ucy5yYXdSZXNwb25zZTtcbiAgICB0aGlzLmxvZ3Byb2JzID0gb3B0aW9ucy5sb2dwcm9icztcbiAgfVxuICAvKipcbiAgQ29udmVydHMgdGhlIG9iamVjdCB0byBhIEpTT04gcmVzcG9uc2UuXG4gIFRoZSByZXNwb25zZSB3aWxsIGhhdmUgYSBzdGF0dXMgY29kZSBvZiAyMDAgYW5kIGEgY29udGVudCB0eXBlIG9mIGBhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04YC5cbiAgICAgKi9cbiAgdG9Kc29uUmVzcG9uc2UoaW5pdCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHRoaXMub2JqZWN0KSwge1xuICAgICAgc3RhdHVzOiAoX2EgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hIDogMjAwLFxuICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufTtcbnZhciBleHBlcmltZW50YWxfZ2VuZXJhdGVPYmplY3QgPSBnZW5lcmF0ZU9iamVjdDtcblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvc3RyZWFtLW9iamVjdC50c1xuaW1wb3J0IHsgc2FmZVZhbGlkYXRlVHlwZXMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHtcbiAgaXNEZWVwRXF1YWxEYXRhLFxuICBwYXJzZVBhcnRpYWxKc29uXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIGNvcmUvdXRpbC9hc3luYy1pdGVyYWJsZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oc291cmNlLCB0cmFuc2Zvcm1lcikge1xuICBjb25zdCB0cmFuc2Zvcm1lZFN0cmVhbSA9IHNvdXJjZS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHRyYW5zZm9ybWVyKVxuICApO1xuICB0cmFuc2Zvcm1lZFN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSAoKSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gdHJhbnNmb3JtZWRTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIHJldHVybiBkb25lID8geyBkb25lOiB0cnVlLCB2YWx1ZTogdm9pZCAwIH0gOiB7IGRvbmU6IGZhbHNlLCB2YWx1ZSB9O1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIHJldHVybiB0cmFuc2Zvcm1lZFN0cmVhbTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvc3RyZWFtLW9iamVjdC50c1xuYXN5bmMgZnVuY3Rpb24gc3RyZWFtT2JqZWN0KHtcbiAgbW9kZWwsXG4gIHNjaGVtYSxcbiAgbW9kZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgb25GaW5pc2gsXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgY29uc3QganNvblNjaGVtYSA9IGNvbnZlcnRab2RUb0pTT05TY2hlbWEoc2NoZW1hKTtcbiAgaWYgKG1vZGUgPT09IFwiYXV0b1wiIHx8IG1vZGUgPT0gbnVsbCkge1xuICAgIG1vZGUgPSBtb2RlbC5kZWZhdWx0T2JqZWN0R2VuZXJhdGlvbk1vZGU7XG4gIH1cbiAgbGV0IGNhbGxPcHRpb25zO1xuICBsZXQgdHJhbnNmb3JtZXI7XG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgXCJqc29uXCI6IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IGdldFZhbGlkYXRlZFByb21wdCh7XG4gICAgICAgIHN5c3RlbTogaW5qZWN0SnNvblNjaGVtYUludG9TeXN0ZW0oeyBzeXN0ZW0sIHNjaGVtYToganNvblNjaGVtYSB9KSxcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBtZXNzYWdlc1xuICAgICAgfSk7XG4gICAgICBjYWxsT3B0aW9ucyA9IHtcbiAgICAgICAgbW9kZTogeyB0eXBlOiBcIm9iamVjdC1qc29uXCIgfSxcbiAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgIGlucHV0Rm9ybWF0OiB2YWxpZGF0ZWRQcm9tcHQudHlwZSxcbiAgICAgICAgcHJvbXB0OiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHZhbGlkYXRlZFByb21wdCksXG4gICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICBoZWFkZXJzXG4gICAgICB9O1xuICAgICAgdHJhbnNmb3JtZXIgPSB7XG4gICAgICAgIHRyYW5zZm9ybTogKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudGV4dERlbHRhKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJncmFtbWFyXCI6IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IGdldFZhbGlkYXRlZFByb21wdCh7XG4gICAgICAgIHN5c3RlbTogaW5qZWN0SnNvblNjaGVtYUludG9TeXN0ZW0oeyBzeXN0ZW0sIHNjaGVtYToganNvblNjaGVtYSB9KSxcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBtZXNzYWdlc1xuICAgICAgfSk7XG4gICAgICBjYWxsT3B0aW9ucyA9IHtcbiAgICAgICAgbW9kZTogeyB0eXBlOiBcIm9iamVjdC1ncmFtbWFyXCIsIHNjaGVtYToganNvblNjaGVtYSB9LFxuICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgaW5wdXRGb3JtYXQ6IHZhbGlkYXRlZFByb21wdC50eXBlLFxuICAgICAgICBwcm9tcHQ6IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQodmFsaWRhdGVkUHJvbXB0KSxcbiAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH07XG4gICAgICB0cmFuc2Zvcm1lciA9IHtcbiAgICAgICAgdHJhbnNmb3JtOiAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay50ZXh0RGVsdGEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gZ2V0VmFsaWRhdGVkUHJvbXB0KHtcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2VzXG4gICAgICB9KTtcbiAgICAgIGNhbGxPcHRpb25zID0ge1xuICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgdHlwZTogXCJvYmplY3QtdG9vbFwiLFxuICAgICAgICAgIHRvb2w6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgIG5hbWU6IFwianNvblwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiUmVzcG9uZCB3aXRoIGEgSlNPTiBvYmplY3QuXCIsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBqc29uU2NoZW1hXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgaW5wdXRGb3JtYXQ6IHZhbGlkYXRlZFByb21wdC50eXBlLFxuICAgICAgICBwcm9tcHQ6IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQodmFsaWRhdGVkUHJvbXB0KSxcbiAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH07XG4gICAgICB0cmFuc2Zvcm1lciA9IHtcbiAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLWRlbHRhXCI6XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay5hcmdzVGV4dERlbHRhKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2Ugdm9pZCAwOiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbCBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCBvYmplY3QgZ2VuZXJhdGlvbiBtb2RlLlwiKTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG1vZGU7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG1vZGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmV0cnkoKCkgPT4gbW9kZWwuZG9TdHJlYW0oY2FsbE9wdGlvbnMpKTtcbiAgcmV0dXJuIG5ldyBTdHJlYW1PYmplY3RSZXN1bHQoe1xuICAgIHN0cmVhbTogcmVzdWx0LnN0cmVhbS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKHRyYW5zZm9ybWVyKSksXG4gICAgd2FybmluZ3M6IHJlc3VsdC53YXJuaW5ncyxcbiAgICByYXdSZXNwb25zZTogcmVzdWx0LnJhd1Jlc3BvbnNlLFxuICAgIHNjaGVtYSxcbiAgICBvbkZpbmlzaFxuICB9KTtcbn1cbnZhciBTdHJlYW1PYmplY3RSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBzdHJlYW0sXG4gICAgd2FybmluZ3MsXG4gICAgcmF3UmVzcG9uc2UsXG4gICAgc2NoZW1hLFxuICAgIG9uRmluaXNoXG4gIH0pIHtcbiAgICB0aGlzLndhcm5pbmdzID0gd2FybmluZ3M7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IHJhd1Jlc3BvbnNlO1xuICAgIGxldCByZXNvbHZlT2JqZWN0O1xuICAgIGxldCByZWplY3RPYmplY3Q7XG4gICAgdGhpcy5vYmplY3QgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByZXNvbHZlT2JqZWN0ID0gcmVzb2x2ZTtcbiAgICAgIHJlamVjdE9iamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgICBsZXQgcmVzb2x2ZVVzYWdlO1xuICAgIHRoaXMudXNhZ2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgcmVzb2x2ZVVzYWdlID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgICBsZXQgdXNhZ2U7XG4gICAgbGV0IG9iamVjdDtcbiAgICBsZXQgZXJyb3I7XG4gICAgbGV0IGFjY3VtdWxhdGVkVGV4dCA9IFwiXCI7XG4gICAgbGV0IGRlbHRhID0gXCJcIjtcbiAgICBsZXQgbGF0ZXN0T2JqZWN0ID0gdm9pZCAwO1xuICAgIHRoaXMub3JpZ2luYWxTdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYWNjdW11bGF0ZWRUZXh0ICs9IGNodW5rO1xuICAgICAgICAgICAgZGVsdGEgKz0gY2h1bms7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50T2JqZWN0ID0gcGFyc2VQYXJ0aWFsSnNvbihcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZWRUZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFpc0RlZXBFcXVhbERhdGEobGF0ZXN0T2JqZWN0LCBjdXJyZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICBsYXRlc3RPYmplY3QgPSBjdXJyZW50T2JqZWN0O1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgb2JqZWN0OiBjdXJyZW50T2JqZWN0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgIHRleHREZWx0YTogZGVsdGFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGRlbHRhID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICAgICAgaWYgKGRlbHRhICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgdGV4dERlbHRhOiBkZWx0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHVzYWdlID0gY2FsY3VsYXRlVG9rZW5Vc2FnZShjaHVuay51c2FnZSk7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IC4uLmNodW5rLCB1c2FnZSB9KTtcbiAgICAgICAgICAgICAgcmVzb2x2ZVVzYWdlKHVzYWdlKTtcbiAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGF0ZXN0T2JqZWN0LFxuICAgICAgICAgICAgICAgIHNjaGVtYVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25SZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIG9iamVjdCA9IHZhbGlkYXRpb25SZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZU9iamVjdChvYmplY3QpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yID0gdmFsaWRhdGlvblJlc3VsdC5lcnJvcjtcbiAgICAgICAgICAgICAgICByZWplY3RPYmplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGludm9rZSBvbkZpbmlzaCBjYWxsYmFjayBhbmQgcmVzb2x2ZSB0b29sUmVzdWx0cyBwcm9taXNlIHdoZW4gdGhlIHN0cmVhbSBpcyBhYm91dCB0byBjbG9zZTpcbiAgICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCAob25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHtcbiAgICAgICAgICAgICAgdXNhZ2U6IHVzYWdlICE9IG51bGwgPyB1c2FnZSA6IHtcbiAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IE5hTixcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBOYU4sXG4gICAgICAgICAgICAgICAgdG90YWxUb2tlbnM6IE5hTlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICByYXdSZXNwb25zZSxcbiAgICAgICAgICAgICAgd2FybmluZ3NcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICAvKipcbiAgU3RyZWFtIG9mIHBhcnRpYWwgb2JqZWN0cy4gSXQgZ2V0cyBtb3JlIGNvbXBsZXRlIGFzIHRoZSBzdHJlYW0gcHJvZ3Jlc3Nlcy5cbiAgICBcbiAgTm90ZSB0aGF0IHRoZSBwYXJ0aWFsIG9iamVjdCBpcyBub3QgdmFsaWRhdGVkLiBcbiAgSWYgeW91IHdhbnQgdG8gYmUgY2VydGFpbiB0aGF0IHRoZSBhY3R1YWwgY29udGVudCBtYXRjaGVzIHlvdXIgc2NoZW1hLCB5b3UgbmVlZCB0byBpbXBsZW1lbnQgeW91ciBvd24gdmFsaWRhdGlvbiBmb3IgcGFydGlhbCByZXN1bHRzLlxuICAgICAqL1xuICBnZXQgcGFydGlhbE9iamVjdFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLm9yaWdpbmFsU3RyZWFtLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLm9iamVjdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihjaHVuay5lcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bms7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgVGV4dCBzdHJlYW0gb2YgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGdlbmVyYXRlZCBvYmplY3QuIEl0IGNvbnRhaW5zIHRleHQgY2h1bmtzLiBcbiAgV2hlbiB0aGUgc3RyZWFtIGlzIGZpbmlzaGVkLCB0aGUgb2JqZWN0IGlzIHZhbGlkIEpTT04gdGhhdCBjYW4gYmUgcGFyc2VkLlxuICAgICAqL1xuICBnZXQgdGV4dFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLm9yaWdpbmFsU3RyZWFtLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay50ZXh0RGVsdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihjaHVuay5lcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bms7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgU3RyZWFtIG9mIGRpZmZlcmVudCB0eXBlcyBvZiBldmVudHMsIGluY2x1ZGluZyBwYXJ0aWFsIG9iamVjdHMsIGVycm9ycywgYW5kIGZpbmlzaCBldmVudHMuXG4gICAgICovXG4gIGdldCBmdWxsU3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMub3JpZ2luYWxTdHJlYW0sIHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICBXcml0ZXMgdGV4dCBkZWx0YSBvdXRwdXQgdG8gYSBOb2RlLmpzIHJlc3BvbnNlLWxpa2Ugb2JqZWN0LlxuICBJdCBzZXRzIGEgYENvbnRlbnQtVHlwZWAgaGVhZGVyIHRvIGB0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04YCBhbmQgXG4gIHdyaXRlcyBlYWNoIHRleHQgZGVsdGEgYXMgYSBzZXBhcmF0ZSBjaHVuay5cbiAgXG4gIEBwYXJhbSByZXNwb25zZSBBIE5vZGUuanMgcmVzcG9uc2UtbGlrZSBvYmplY3QgKFNlcnZlclJlc3BvbnNlKS5cbiAgQHBhcmFtIGluaXQgT3B0aW9uYWwgaGVhZGVycyBhbmQgc3RhdHVzIGNvZGUuXG4gICAgICovXG4gIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCkge1xuICAgIHZhciBfYTtcbiAgICByZXNwb25zZS53cml0ZUhlYWQoKF9hID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYSA6IDIwMCwge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAuLi5pbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnNcbiAgICB9KTtcbiAgICBjb25zdCByZWFkZXIgPSB0aGlzLnRleHRTdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpLmdldFJlYWRlcigpO1xuICAgIGNvbnN0IHJlYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICByZXNwb25zZS53cml0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZWFkKCk7XG4gIH1cbiAgLyoqXG4gIENyZWF0ZXMgYSBzaW1wbGUgdGV4dCBzdHJlYW0gcmVzcG9uc2UuXG4gIFRoZSByZXNwb25zZSBoYXMgYSBgQ29udGVudC1UeXBlYCBoZWFkZXIgc2V0IHRvIGB0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04YC5cbiAgRWFjaCB0ZXh0IGRlbHRhIGlzIGVuY29kZWQgYXMgVVRGLTggYW5kIHNlbnQgYXMgYSBzZXBhcmF0ZSBjaHVuay5cbiAgTm9uLXRleHQtZGVsdGEgZXZlbnRzIGFyZSBpZ25vcmVkLlxuICBcbiAgQHBhcmFtIGluaXQgT3B0aW9uYWwgaGVhZGVycyBhbmQgc3RhdHVzIGNvZGUuXG4gICAgICovXG4gIHRvVGV4dFN0cmVhbVJlc3BvbnNlKGluaXQpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLnRleHRTdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpLCB7XG4gICAgICBzdGF0dXM6IChfYSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2EgOiAyMDAsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlUmVzcG9uc2VIZWFkZXJzKGluaXQsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59O1xudmFyIGV4cGVyaW1lbnRhbF9zdHJlYW1PYmplY3QgPSBzdHJlYW1PYmplY3Q7XG5cbi8vIGNvcmUvdXRpbC9pcy1ub24tZW1wdHktb2JqZWN0LnRzXG5mdW5jdGlvbiBpc05vbkVtcHR5T2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgT2JqZWN0LmtleXMob2JqZWN0KS5sZW5ndGggPiAwO1xufVxuXG4vLyBjb3JlL3Byb21wdC9wcmVwYXJlLXRvb2xzLWFuZC10b29sLWNob2ljZS50c1xuZnVuY3Rpb24gcHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7XG4gIHRvb2xzLFxuICB0b29sQ2hvaWNlXG59KSB7XG4gIGlmICghaXNOb25FbXB0eU9iamVjdCh0b29scykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbHM6IHZvaWQgMCxcbiAgICAgIHRvb2xDaG9pY2U6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b29sczogT2JqZWN0LmVudHJpZXModG9vbHMpLm1hcCgoW25hbWUsIHRvb2wyXSkgPT4gKHtcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgIG5hbWUsXG4gICAgICBkZXNjcmlwdGlvbjogdG9vbDIuZGVzY3JpcHRpb24sXG4gICAgICBwYXJhbWV0ZXJzOiBjb252ZXJ0Wm9kVG9KU09OU2NoZW1hKHRvb2wyLnBhcmFtZXRlcnMpXG4gICAgfSkpLFxuICAgIHRvb2xDaG9pY2U6IHRvb2xDaG9pY2UgPT0gbnVsbCA/IHsgdHlwZTogXCJhdXRvXCIgfSA6IHR5cGVvZiB0b29sQ2hvaWNlID09PSBcInN0cmluZ1wiID8geyB0eXBlOiB0b29sQ2hvaWNlIH0gOiB7IHR5cGU6IFwidG9vbFwiLCB0b29sTmFtZTogdG9vbENob2ljZS50b29sTmFtZSB9XG4gIH07XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC90b29sLWNhbGwudHNcbmltcG9ydCB7XG4gIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IsXG4gIE5vU3VjaFRvb2xFcnJvclxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgc2FmZVBhcnNlSlNPTiBhcyBzYWZlUGFyc2VKU09OMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5mdW5jdGlvbiBwYXJzZVRvb2xDYWxsKHtcbiAgdG9vbENhbGwsXG4gIHRvb2xzXG59KSB7XG4gIGNvbnN0IHRvb2xOYW1lID0gdG9vbENhbGwudG9vbE5hbWU7XG4gIGlmICh0b29scyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7IHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSB9KTtcbiAgfVxuICBjb25zdCB0b29sMiA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgaWYgKHRvb2wyID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHtcbiAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgIGF2YWlsYWJsZVRvb2xzOiBPYmplY3Qua2V5cyh0b29scylcbiAgICB9KTtcbiAgfVxuICBjb25zdCBwYXJzZVJlc3VsdCA9IHNhZmVQYXJzZUpTT04yKHtcbiAgICB0ZXh0OiB0b29sQ2FsbC5hcmdzLFxuICAgIHNjaGVtYTogdG9vbDIucGFyYW1ldGVyc1xuICB9KTtcbiAgaWYgKHBhcnNlUmVzdWx0LnN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRUb29sQXJndW1lbnRzRXJyb3Ioe1xuICAgICAgdG9vbE5hbWUsXG4gICAgICB0b29sQXJnczogdG9vbENhbGwuYXJncyxcbiAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgIHRvb2xOYW1lLFxuICAgIGFyZ3M6IHBhcnNlUmVzdWx0LnZhbHVlXG4gIH07XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZS10ZXh0LnRzXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVRleHQoe1xuICBtb2RlbCxcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIG1heEF1dG9tYXRpY1JvdW5kdHJpcHMgPSAwLFxuICBtYXhUb29sUm91bmR0cmlwcyA9IG1heEF1dG9tYXRpY1JvdW5kdHJpcHMsXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IGdldFZhbGlkYXRlZFByb21wdCh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KTtcbiAgY29uc3QgbW9kZSA9IHtcbiAgICB0eXBlOiBcInJlZ3VsYXJcIixcbiAgICAuLi5wcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHsgdG9vbHMsIHRvb2xDaG9pY2UgfSlcbiAgfTtcbiAgY29uc3QgY2FsbFNldHRpbmdzID0gcHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh2YWxpZGF0ZWRQcm9tcHQpO1xuICBsZXQgY3VycmVudE1vZGVsUmVzcG9uc2U7XG4gIGxldCBjdXJyZW50VG9vbENhbGxzID0gW107XG4gIGxldCBjdXJyZW50VG9vbFJlc3VsdHMgPSBbXTtcbiAgbGV0IHJvdW5kdHJpcHMgPSAwO1xuICBjb25zdCByZXNwb25zZU1lc3NhZ2VzID0gW107XG4gIGRvIHtcbiAgICBjdXJyZW50TW9kZWxSZXNwb25zZSA9IGF3YWl0IHJldHJ5KCgpID0+IHtcbiAgICAgIHJldHVybiBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgbW9kZSxcbiAgICAgICAgLi4uY2FsbFNldHRpbmdzLFxuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgYSByb3VuZHRyaXAsIHdlIG5lZWQgdG8gc3dpdGNoIHRvIG1lc3NhZ2VzIGZvcm1hdDpcbiAgICAgICAgaW5wdXRGb3JtYXQ6IHJvdW5kdHJpcHMgPT09IDAgPyB2YWxpZGF0ZWRQcm9tcHQudHlwZSA6IFwibWVzc2FnZXNcIixcbiAgICAgICAgcHJvbXB0OiBwcm9tcHRNZXNzYWdlcyxcbiAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGN1cnJlbnRUb29sQ2FsbHMgPSAoKF9hID0gY3VycmVudE1vZGVsUmVzcG9uc2UudG9vbENhbGxzKSAhPSBudWxsID8gX2EgOiBbXSkubWFwKFxuICAgICAgKG1vZGVsVG9vbENhbGwpID0+IHBhcnNlVG9vbENhbGwoeyB0b29sQ2FsbDogbW9kZWxUb29sQ2FsbCwgdG9vbHMgfSlcbiAgICApO1xuICAgIGN1cnJlbnRUb29sUmVzdWx0cyA9IHRvb2xzID09IG51bGwgPyBbXSA6IGF3YWl0IGV4ZWN1dGVUb29scyh7IHRvb2xDYWxsczogY3VycmVudFRvb2xDYWxscywgdG9vbHMgfSk7XG4gICAgY29uc3QgbmV3UmVzcG9uc2VNZXNzYWdlcyA9IHRvUmVzcG9uc2VNZXNzYWdlcyh7XG4gICAgICB0ZXh0OiAoX2IgPSBjdXJyZW50TW9kZWxSZXNwb25zZS50ZXh0KSAhPSBudWxsID8gX2IgOiBcIlwiLFxuICAgICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgICAgdG9vbFJlc3VsdHM6IGN1cnJlbnRUb29sUmVzdWx0c1xuICAgIH0pO1xuICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaCguLi5uZXdSZXNwb25zZU1lc3NhZ2VzKTtcbiAgICBwcm9tcHRNZXNzYWdlcy5wdXNoKFxuICAgICAgLi4ubmV3UmVzcG9uc2VNZXNzYWdlcy5tYXAoY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UpXG4gICAgKTtcbiAgfSB3aGlsZSAoXG4gICAgLy8gdGhlcmUgYXJlIHRvb2wgY2FsbHM6XG4gICAgY3VycmVudFRvb2xDYWxscy5sZW5ndGggPiAwICYmIC8vIGFsbCBjdXJyZW50IHRvb2wgY2FsbHMgaGF2ZSByZXN1bHRzOlxuICAgIGN1cnJlbnRUb29sUmVzdWx0cy5sZW5ndGggPT09IGN1cnJlbnRUb29sQ2FsbHMubGVuZ3RoICYmIC8vIHRoZSBudW1iZXIgb2Ygcm91bmR0cmlwcyBpcyBsZXNzIHRoYW4gdGhlIG1heGltdW06XG4gICAgcm91bmR0cmlwcysrIDwgbWF4VG9vbFJvdW5kdHJpcHNcbiAgKTtcbiAgcmV0dXJuIG5ldyBHZW5lcmF0ZVRleHRSZXN1bHQoe1xuICAgIC8vIEFsd2F5cyByZXR1cm4gYSBzdHJpbmcgc28gdGhhdCB0aGUgY2FsbGVyIGRvZXNuJ3QgaGF2ZSB0byBjaGVjayBmb3IgdW5kZWZpbmVkLlxuICAgIC8vIElmIHRoZXkgbmVlZCB0byBjaGVjayBpZiB0aGUgbW9kZWwgZGlkIG5vdCByZXR1cm4gYW55IHRleHQsXG4gICAgLy8gdGhleSBjYW4gY2hlY2sgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nOlxuICAgIHRleHQ6IChfYyA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnRleHQpICE9IG51bGwgPyBfYyA6IFwiXCIsXG4gICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgIHRvb2xSZXN1bHRzOiBjdXJyZW50VG9vbFJlc3VsdHMsXG4gICAgZmluaXNoUmVhc29uOiBjdXJyZW50TW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24sXG4gICAgdXNhZ2U6IGNhbGN1bGF0ZVRva2VuVXNhZ2UoY3VycmVudE1vZGVsUmVzcG9uc2UudXNhZ2UpLFxuICAgIHdhcm5pbmdzOiBjdXJyZW50TW9kZWxSZXNwb25zZS53YXJuaW5ncyxcbiAgICByYXdSZXNwb25zZTogY3VycmVudE1vZGVsUmVzcG9uc2UucmF3UmVzcG9uc2UsXG4gICAgbG9ncHJvYnM6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmxvZ3Byb2JzLFxuICAgIHJlc3BvbnNlTWVzc2FnZXNcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBleGVjdXRlVG9vbHMoe1xuICB0b29sQ2FsbHMsXG4gIHRvb2xzXG59KSB7XG4gIGNvbnN0IHRvb2xSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgdG9vbENhbGxzLm1hcChhc3luYyAodG9vbENhbGwpID0+IHtcbiAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbENhbGwudG9vbE5hbWVdO1xuICAgICAgaWYgKCh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIuZXhlY3V0ZSkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdG9vbDIuZXhlY3V0ZSh0b29sQ2FsbC5hcmdzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgYXJnczogdG9vbENhbGwuYXJncyxcbiAgICAgICAgcmVzdWx0XG4gICAgICB9O1xuICAgIH0pXG4gICk7XG4gIHJldHVybiB0b29sUmVzdWx0cy5maWx0ZXIoXG4gICAgKHJlc3VsdCkgPT4gcmVzdWx0ICE9IG51bGxcbiAgKTtcbn1cbnZhciBHZW5lcmF0ZVRleHRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnRleHQgPSBvcHRpb25zLnRleHQ7XG4gICAgdGhpcy50b29sQ2FsbHMgPSBvcHRpb25zLnRvb2xDYWxscztcbiAgICB0aGlzLnRvb2xSZXN1bHRzID0gb3B0aW9ucy50b29sUmVzdWx0cztcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IG9wdGlvbnMuZmluaXNoUmVhc29uO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmF3UmVzcG9uc2UgPSBvcHRpb25zLnJhd1Jlc3BvbnNlO1xuICAgIHRoaXMubG9ncHJvYnMgPSBvcHRpb25zLmxvZ3Byb2JzO1xuICAgIHRoaXMucmVzcG9uc2VNZXNzYWdlcyA9IG9wdGlvbnMucmVzcG9uc2VNZXNzYWdlcztcbiAgfVxufTtcbmZ1bmN0aW9uIHRvUmVzcG9uc2VNZXNzYWdlcyh7XG4gIHRleHQsXG4gIHRvb2xDYWxscyxcbiAgdG9vbFJlc3VsdHNcbn0pIHtcbiAgY29uc3QgcmVzcG9uc2VNZXNzYWdlcyA9IFtdO1xuICByZXNwb25zZU1lc3NhZ2VzLnB1c2goe1xuICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQgfSwgLi4udG9vbENhbGxzXVxuICB9KTtcbiAgaWYgKHRvb2xSZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICByZXNwb25zZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICBjb250ZW50OiB0b29sUmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gKHtcbiAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICB0b29sQ2FsbElkOiByZXN1bHQudG9vbENhbGxJZCxcbiAgICAgICAgdG9vbE5hbWU6IHJlc3VsdC50b29sTmFtZSxcbiAgICAgICAgcmVzdWx0OiByZXN1bHQucmVzdWx0XG4gICAgICB9KSlcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzcG9uc2VNZXNzYWdlcztcbn1cbnZhciBleHBlcmltZW50YWxfZ2VuZXJhdGVUZXh0ID0gZ2VuZXJhdGVUZXh0O1xuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvcnVuLXRvb2xzLXRyYW5zZm9ybWF0aW9uLnRzXG5pbXBvcnQgeyBOb1N1Y2hUb29sRXJyb3IgYXMgTm9TdWNoVG9vbEVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmZ1bmN0aW9uIHJ1blRvb2xzVHJhbnNmb3JtYXRpb24oe1xuICB0b29scyxcbiAgZ2VuZXJhdG9yU3RyZWFtXG59KSB7XG4gIGxldCBjYW5DbG9zZSA9IGZhbHNlO1xuICBjb25zdCBvdXRzdGFuZGluZ1Rvb2xDYWxscyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIgPSBudWxsO1xuICBjb25zdCB0b29sUmVzdWx0c1N0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBmb3J3YXJkU3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVuay50eXBlO1xuICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gY2h1bmsudG9vbE5hbWU7XG4gICAgICAgICAgaWYgKHRvb2xzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBlcnJvcjogbmV3IE5vU3VjaFRvb2xFcnJvcjIoeyB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbE5hbWVdO1xuICAgICAgICAgIGlmICh0b29sMiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBOb1N1Y2hUb29sRXJyb3IyKHtcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlVG9vbHM6IE9iamVjdC5rZXlzKHRvb2xzKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsID0gcGFyc2VUb29sQ2FsbCh7XG4gICAgICAgICAgICAgIHRvb2xDYWxsOiBjaHVuayxcbiAgICAgICAgICAgICAgdG9vbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRvb2xDYWxsKTtcbiAgICAgICAgICAgIGlmICh0b29sMi5leGVjdXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbEV4ZWN1dGlvbklkID0gZ2VuZXJhdGVJZCgpO1xuICAgICAgICAgICAgICBvdXRzdGFuZGluZ1Rvb2xDYWxscy5hZGQodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgdG9vbDIuZXhlY3V0ZSh0b29sQ2FsbC5hcmdzKS50aGVuKFxuICAgICAgICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgLi4udG9vbENhbGwsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIG91dHN0YW5kaW5nVG9vbENhbGxzLmRlbGV0ZSh0b29sRXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNhbkNsb3NlICYmIG91dHN0YW5kaW5nVG9vbENhbGxzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBvdXRzdGFuZGluZ1Rvb2xDYWxscy5kZWxldGUodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjYW5DbG9zZSAmJiBvdXRzdGFuZGluZ1Rvb2xDYWxscy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb246IGNodW5rLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIGxvZ3Byb2JzOiBjaHVuay5sb2dwcm9icyxcbiAgICAgICAgICAgIHVzYWdlOiBjYWxjdWxhdGVUb2tlblVzYWdlKGNodW5rLnVzYWdlKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtZGVsdGFcIjoge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bmtUeXBlO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZmx1c2goKSB7XG4gICAgICBjYW5DbG9zZSA9IHRydWU7XG4gICAgICBpZiAob3V0c3RhbmRpbmdUb29sQ2FsbHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICBnZW5lcmF0b3JTdHJlYW0ucGlwZVRocm91Z2goZm9yd2FyZFN0cmVhbSkucGlwZVRvKFxuICAgICAgICAgIG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgICAgICB3cml0ZShjaHVuaykge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICksXG4gICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtLnBpcGVUbyhcbiAgICAgICAgICBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIF0pO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9zdHJlYW0tdGV4dC50c1xuYXN5bmMgZnVuY3Rpb24gc3RyZWFtVGV4dCh7XG4gIG1vZGVsLFxuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgb25GaW5pc2gsXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gZ2V0VmFsaWRhdGVkUHJvbXB0KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pO1xuICBjb25zdCB7IHN0cmVhbSwgd2FybmluZ3MsIHJhd1Jlc3BvbnNlIH0gPSBhd2FpdCByZXRyeShcbiAgICAoKSA9PiBtb2RlbC5kb1N0cmVhbSh7XG4gICAgICBtb2RlOiB7XG4gICAgICAgIHR5cGU6IFwicmVndWxhclwiLFxuICAgICAgICAuLi5wcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHsgdG9vbHMsIHRvb2xDaG9pY2UgfSlcbiAgICAgIH0sXG4gICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgIGlucHV0Rm9ybWF0OiB2YWxpZGF0ZWRQcm9tcHQudHlwZSxcbiAgICAgIHByb21wdDogY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh2YWxpZGF0ZWRQcm9tcHQpLFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBoZWFkZXJzXG4gICAgfSlcbiAgKTtcbiAgcmV0dXJuIG5ldyBTdHJlYW1UZXh0UmVzdWx0KHtcbiAgICBzdHJlYW06IHJ1blRvb2xzVHJhbnNmb3JtYXRpb24oe1xuICAgICAgdG9vbHMsXG4gICAgICBnZW5lcmF0b3JTdHJlYW06IHN0cmVhbVxuICAgIH0pLFxuICAgIHdhcm5pbmdzLFxuICAgIHJhd1Jlc3BvbnNlLFxuICAgIG9uRmluaXNoXG4gIH0pO1xufVxudmFyIFN0cmVhbVRleHRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBzdHJlYW0sXG4gICAgd2FybmluZ3MsXG4gICAgcmF3UmVzcG9uc2UsXG4gICAgb25GaW5pc2hcbiAgfSkge1xuICAgIHRoaXMud2FybmluZ3MgPSB3YXJuaW5ncztcbiAgICB0aGlzLnJhd1Jlc3BvbnNlID0gcmF3UmVzcG9uc2U7XG4gICAgdGhpcy5vbkZpbmlzaCA9IG9uRmluaXNoO1xuICAgIGxldCByZXNvbHZlVXNhZ2U7XG4gICAgdGhpcy51c2FnZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICByZXNvbHZlVXNhZ2UgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGxldCByZXNvbHZlRmluaXNoUmVhc29uO1xuICAgIHRoaXMuZmluaXNoUmVhc29uID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHJlc29sdmVGaW5pc2hSZWFzb24gPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGxldCByZXNvbHZlVGV4dDtcbiAgICB0aGlzLnRleHQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgcmVzb2x2ZVRleHQgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGxldCByZXNvbHZlVG9vbENhbGxzO1xuICAgIHRoaXMudG9vbENhbGxzID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHJlc29sdmVUb29sQ2FsbHMgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGxldCByZXNvbHZlVG9vbFJlc3VsdHM7XG4gICAgdGhpcy50b29sUmVzdWx0cyA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICByZXNvbHZlVG9vbFJlc3VsdHMgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGxldCBmaW5pc2hSZWFzb247XG4gICAgbGV0IHVzYWdlO1xuICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICBjb25zdCB0b29sQ2FsbHMgPSBbXTtcbiAgICBjb25zdCB0b29sUmVzdWx0cyA9IFtdO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHRoaXMub3JpZ2luYWxTdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICAgIHRleHQgKz0gY2h1bmsudGV4dERlbHRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0b29sLWNhbGxcIikge1xuICAgICAgICAgICAgdG9vbENhbGxzLnB1c2goY2h1bmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiKSB7XG4gICAgICAgICAgICB0b29sUmVzdWx0cy5wdXNoKGNodW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwiZmluaXNoXCIpIHtcbiAgICAgICAgICAgIHVzYWdlID0gY2h1bmsudXNhZ2U7XG4gICAgICAgICAgICBmaW5pc2hSZWFzb24gPSBjaHVuay5maW5pc2hSZWFzb247XG4gICAgICAgICAgICByZXNvbHZlVXNhZ2UodXNhZ2UpO1xuICAgICAgICAgICAgcmVzb2x2ZUZpbmlzaFJlYXNvbihmaW5pc2hSZWFzb24pO1xuICAgICAgICAgICAgcmVzb2x2ZVRleHQodGV4dCk7XG4gICAgICAgICAgICByZXNvbHZlVG9vbENhbGxzKHRvb2xDYWxscyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBpbnZva2Ugb25GaW5pc2ggY2FsbGJhY2sgYW5kIHJlc29sdmUgdG9vbFJlc3VsdHMgcHJvbWlzZSB3aGVuIHRoZSBzdHJlYW0gaXMgYWJvdXQgdG8gY2xvc2U6XG4gICAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc29sdmVUb29sUmVzdWx0cyh0b29sUmVzdWx0cyk7XG4gICAgICAgICAgICBhd2FpdCAoKF9hID0gc2VsZi5vbkZpbmlzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoc2VsZiwge1xuICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IGZpbmlzaFJlYXNvbiAhPSBudWxsID8gZmluaXNoUmVhc29uIDogXCJ1bmtub3duXCIsXG4gICAgICAgICAgICAgIHVzYWdlOiB1c2FnZSAhPSBudWxsID8gdXNhZ2UgOiB7XG4gICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiBOYU4sXG4gICAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogTmFOLFxuICAgICAgICAgICAgICAgIHRvdGFsVG9rZW5zOiBOYU5cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgdG9vbENhbGxzLFxuICAgICAgICAgICAgICAvLyBUaGUgdG9vbCByZXN1bHRzIGFyZSBpbmZlcnJlZCBhcyBhIG5ldmVyW10gdHlwZSwgYmVjYXVzZSB0aGV5IGFyZVxuICAgICAgICAgICAgICAvLyBvcHRpb25hbCBhbmQgdGhlIGV4ZWN1dGUgbWV0aG9kIHdpdGggYW4gaW5mZXJyZWQgcmVzdWx0IHR5cGUgaXNcbiAgICAgICAgICAgICAgLy8gb3B0aW9uYWwgYXMgd2VsbC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gY2FzdCB0aGUgdG9vbFJlc3VsdHMgdG8gYW55LlxuICAgICAgICAgICAgICAvLyBUaGUgdHlwZSBleHBvc2VkIHRvIHRoZSB1c2VycyB3aWxsIGJlIGNvcnJlY3RseSBpbmZlcnJlZC5cbiAgICAgICAgICAgICAgdG9vbFJlc3VsdHMsXG4gICAgICAgICAgICAgIHJhd1Jlc3BvbnNlLFxuICAgICAgICAgICAgICB3YXJuaW5nc1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICAvKipcbiAgU3BsaXQgb3V0IGEgbmV3IHN0cmVhbSBmcm9tIHRoZSBvcmlnaW5hbCBzdHJlYW0uXG4gIFRoZSBvcmlnaW5hbCBzdHJlYW0gaXMgcmVwbGFjZWQgdG8gYWxsb3cgZm9yIGZ1cnRoZXIgc3BsaXR0aW5nLFxuICBzaW5jZSB3ZSBkbyBub3Qga25vdyBob3cgbWFueSB0aW1lcyB0aGUgc3RyZWFtIHdpbGwgYmUgc3BsaXQuXG4gIFxuICBOb3RlOiB0aGlzIGxlYWRzIHRvIGJ1ZmZlcmluZyB0aGUgc3RyZWFtIGNvbnRlbnQgb24gdGhlIHNlcnZlci5cbiAgSG93ZXZlciwgdGhlIExMTSByZXN1bHRzIGFyZSBleHBlY3RlZCB0byBiZSBzbWFsbCBlbm91Z2ggdG8gbm90IGNhdXNlIGlzc3Vlcy5cbiAgICAgKi9cbiAgdGVlU3RyZWFtKCkge1xuICAgIGNvbnN0IFtzdHJlYW0xLCBzdHJlYW0yXSA9IHRoaXMub3JpZ2luYWxTdHJlYW0udGVlKCk7XG4gICAgdGhpcy5vcmlnaW5hbFN0cmVhbSA9IHN0cmVhbTI7XG4gICAgcmV0dXJuIHN0cmVhbTE7XG4gIH1cbiAgLyoqXG4gIEEgdGV4dCBzdHJlYW0gdGhhdCByZXR1cm5zIG9ubHkgdGhlIGdlbmVyYXRlZCB0ZXh0IGRlbHRhcy4gWW91IGNhbiB1c2UgaXRcbiAgYXMgZWl0aGVyIGFuIEFzeW5jSXRlcmFibGUgb3IgYSBSZWFkYWJsZVN0cmVhbS4gV2hlbiBhbiBlcnJvciBvY2N1cnMsIHRoZVxuICBzdHJlYW0gd2lsbCB0aHJvdyB0aGUgZXJyb3IuXG4gICAgICovXG4gIGdldCB0ZXh0U3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMudGVlU3RyZWFtKCksIHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICBpZiAoY2h1bmsudGV4dERlbHRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay50ZXh0RGVsdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjaHVuay50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICB0aHJvdyBjaHVuay5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICBBIHN0cmVhbSB3aXRoIGFsbCBldmVudHMsIGluY2x1ZGluZyB0ZXh0IGRlbHRhcywgdG9vbCBjYWxscywgdG9vbCByZXN1bHRzLCBhbmRcbiAgZXJyb3JzLlxuICBZb3UgY2FuIHVzZSBpdCBhcyBlaXRoZXIgYW4gQXN5bmNJdGVyYWJsZSBvciBhIFJlYWRhYmxlU3RyZWFtLiBXaGVuIGFuIGVycm9yIG9jY3VycywgdGhlXG4gIHN0cmVhbSB3aWxsIHRocm93IHRoZSBlcnJvci5cbiAgICAgKi9cbiAgZ2V0IGZ1bGxTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0odGhpcy50ZWVTdHJlYW0oKSwge1xuICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgIGlmIChjaHVuay50ZXh0RGVsdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICBDb252ZXJ0cyB0aGUgcmVzdWx0IHRvIGFuIGBBSVN0cmVhbWAgb2JqZWN0IHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIGBTdHJlYW1pbmdUZXh0UmVzcG9uc2VgLlxuICBJdCBjYW4gYmUgdXNlZCB3aXRoIHRoZSBgdXNlQ2hhdGAgYW5kIGB1c2VDb21wbGV0aW9uYCBob29rcy5cbiAgXG4gIEBwYXJhbSBjYWxsYmFja3MgXG4gIFN0cmVhbSBjYWxsYmFja3MgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBzdHJlYW0gZW1pdHMgZXZlbnRzLlxuICBcbiAgQHJldHVybnMgYW4gYEFJU3RyZWFtYCBvYmplY3QuXG4gICAgICovXG4gIHRvQUlTdHJlYW0oY2FsbGJhY2tzID0ge30pIHtcbiAgICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gXCJcIjtcbiAgICBjb25zdCBjYWxsYmFja1RyYW5zZm9ybWVyID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5vblN0YXJ0KVxuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblN0YXJ0KCk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgIGNvbnN0IHRleHREZWx0YSA9IGNodW5rLnRleHREZWx0YTtcbiAgICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gdGV4dERlbHRhO1xuICAgICAgICAgIGlmIChjYWxsYmFja3Mub25Ub2tlbilcbiAgICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblRva2VuKHRleHREZWx0YSk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5vblRleHQpXG4gICAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25UZXh0KHRleHREZWx0YSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhc3luYyBmbHVzaCgpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkNvbXBsZXRpb24pXG4gICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uQ29tcGxldGlvbihhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwpXG4gICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBzdHJlYW1EYXRhVHJhbnNmb3JtZXIgPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZm9ybWF0U3RyZWFtUGFydChcInRleHRcIiwgY2h1bmsudGV4dERlbHRhKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJ0b29sX2NhbGxcIiwge1xuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3M6IGNodW5rLmFyZ3NcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjpcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcInRvb2xfcmVzdWx0XCIsIHtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhcmdzOiBjaHVuay5hcmdzLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogY2h1bmsucmVzdWx0XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJlcnJvclwiLCBKU09OLnN0cmluZ2lmeShjaHVuay5lcnJvcikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5mdWxsU3RyZWFtLnBpcGVUaHJvdWdoKGNhbGxiYWNrVHJhbnNmb3JtZXIpLnBpcGVUaHJvdWdoKHN0cmVhbURhdGFUcmFuc2Zvcm1lcikucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpO1xuICB9XG4gIC8qKlxuICBXcml0ZXMgc3RyZWFtIGRhdGEgb3V0cHV0IHRvIGEgTm9kZS5qcyByZXNwb25zZS1saWtlIG9iamVjdC5cbiAgSXQgc2V0cyBhIGBDb250ZW50LVR5cGVgIGhlYWRlciB0byBgdGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOGAgYW5kIFxuICB3cml0ZXMgZWFjaCBzdHJlYW0gZGF0YSBwYXJ0IGFzIGEgc2VwYXJhdGUgY2h1bmsuXG4gIFxuICBAcGFyYW0gcmVzcG9uc2UgQSBOb2RlLmpzIHJlc3BvbnNlLWxpa2Ugb2JqZWN0IChTZXJ2ZXJSZXNwb25zZSkuXG4gIEBwYXJhbSBpbml0IE9wdGlvbmFsIGhlYWRlcnMgYW5kIHN0YXR1cyBjb2RlLlxuICAgICAqL1xuICBwaXBlQUlTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBpbml0KSB7XG4gICAgdmFyIF9hO1xuICAgIHJlc3BvbnNlLndyaXRlSGVhZCgoX2EgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hIDogMjAwLCB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgIC4uLmluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IHJlYWRlciA9IHRoaXMudG9BSVN0cmVhbSgpLmdldFJlYWRlcigpO1xuICAgIGNvbnN0IHJlYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICByZXNwb25zZS53cml0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZWFkKCk7XG4gIH1cbiAgLyoqXG4gIFdyaXRlcyB0ZXh0IGRlbHRhIG91dHB1dCB0byBhIE5vZGUuanMgcmVzcG9uc2UtbGlrZSBvYmplY3QuXG4gIEl0IHNldHMgYSBgQ29udGVudC1UeXBlYCBoZWFkZXIgdG8gYHRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThgIGFuZCBcbiAgd3JpdGVzIGVhY2ggdGV4dCBkZWx0YSBhcyBhIHNlcGFyYXRlIGNodW5rLlxuICBcbiAgQHBhcmFtIHJlc3BvbnNlIEEgTm9kZS5qcyByZXNwb25zZS1saWtlIG9iamVjdCAoU2VydmVyUmVzcG9uc2UpLlxuICBAcGFyYW0gaW5pdCBPcHRpb25hbCBoZWFkZXJzIGFuZCBzdGF0dXMgY29kZS5cbiAgICAgKi9cbiAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBpbml0KSB7XG4gICAgdmFyIF9hO1xuICAgIHJlc3BvbnNlLndyaXRlSGVhZCgoX2EgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hIDogMjAwLCB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgIC4uLmluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IHJlYWRlciA9IHRoaXMudGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSkuZ2V0UmVhZGVyKCk7XG4gICAgY29uc3QgcmVhZCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIHJlc3BvbnNlLndyaXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlYWQoKTtcbiAgfVxuICAvKipcbiAgQ29udmVydHMgdGhlIHJlc3VsdCB0byBhIHN0cmVhbWVkIHJlc3BvbnNlIG9iamVjdCB3aXRoIGEgc3RyZWFtIGRhdGEgcGFydCBzdHJlYW0uXG4gIEl0IGNhbiBiZSB1c2VkIHdpdGggdGhlIGB1c2VDaGF0YCBhbmQgYHVzZUNvbXBsZXRpb25gIGhvb2tzLlxuICBcbiAgQHBhcmFtIGluaXQgT3B0aW9uYWwgaGVhZGVycy5cbiAgXG4gIEByZXR1cm4gQSByZXNwb25zZSBvYmplY3QuXG4gICAgICovXG4gIHRvQUlTdHJlYW1SZXNwb25zZShpbml0KSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1pbmdUZXh0UmVzcG9uc2UodGhpcy50b0FJU3RyZWFtKCksIGluaXQpO1xuICB9XG4gIC8qKlxuICBDcmVhdGVzIGEgc2ltcGxlIHRleHQgc3RyZWFtIHJlc3BvbnNlLlxuICBFYWNoIHRleHQgZGVsdGEgaXMgZW5jb2RlZCBhcyBVVEYtOCBhbmQgc2VudCBhcyBhIHNlcGFyYXRlIGNodW5rLlxuICBOb24tdGV4dC1kZWx0YSBldmVudHMgYXJlIGlnbm9yZWQuXG4gIFxuICBAcGFyYW0gaW5pdCBPcHRpb25hbCBoZWFkZXJzIGFuZCBzdGF0dXMgY29kZS5cbiAgICAgKi9cbiAgdG9UZXh0U3RyZWFtUmVzcG9uc2UoaW5pdCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMudGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSksIHtcbiAgICAgIHN0YXR1czogKF9hID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYSA6IDIwMCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCwge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbn07XG52YXIgZXhwZXJpbWVudGFsX3N0cmVhbVRleHQgPSBzdHJlYW1UZXh0O1xuXG4vLyBjb3JlL3Byb21wdC9jb252ZXJ0LXRvLWNvcmUtbWVzc2FnZXMudHNcbmZ1bmN0aW9uIGNvbnZlcnRUb0NvcmVNZXNzYWdlcyhtZXNzYWdlcykge1xuICBjb25zdCBjb3JlTWVzc2FnZXMgPSBbXTtcbiAgZm9yIChjb25zdCB7IHJvbGUsIGNvbnRlbnQsIHRvb2xJbnZvY2F0aW9ucyB9IG9mIG1lc3NhZ2VzKSB7XG4gICAgc3dpdGNoIChyb2xlKSB7XG4gICAgICBjYXNlIFwidXNlclwiOiB7XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHsgcm9sZTogXCJ1c2VyXCIsIGNvbnRlbnQgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImFzc2lzdGFudFwiOiB7XG4gICAgICAgIGlmICh0b29sSW52b2NhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHsgcm9sZTogXCJhc3Npc3RhbnRcIiwgY29udGVudCB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb3JlTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICB7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBjb250ZW50IH0sXG4gICAgICAgICAgICAuLi50b29sSW52b2NhdGlvbnMubWFwKCh7IHRvb2xDYWxsSWQsIHRvb2xOYW1lLCBhcmdzIH0pID0+ICh7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICBhcmdzXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgICBjb3JlTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgICAgY29udGVudDogdG9vbEludm9jYXRpb25zLm1hcChcbiAgICAgICAgICAgICh7IHRvb2xDYWxsSWQsIHRvb2xOYW1lLCBhcmdzLCByZXN1bHQgfSkgPT4gKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcm9sZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmhhbmRsZWQgcm9sZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29yZU1lc3NhZ2VzO1xufVxuXG4vLyBjb3JlL3JlZ2lzdHJ5L2ludmFsaWQtbW9kZWwtaWQtZXJyb3IudHNcbnZhciBJbnZhbGlkTW9kZWxJZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBpZCxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgbW9kZWwgaWQ6ICR7aWR9YFxuICB9KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJBSV9JbnZhbGlkTW9kZWxJZEVycm9yXCI7XG4gICAgdGhpcy5pZCA9IGlkO1xuICB9XG4gIHN0YXRpYyBpc0ludmFsaWRNb2RlbElkRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBcIkFJX0ludmFsaWRNb2RlbElkRXJyb3JcIiAmJiB0eXBlb2YgZXJyb3IuaWQgPT09IFwic3RyaW5nXCI7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIGlkOiB0aGlzLmlkXG4gICAgfTtcbiAgfVxufTtcblxuLy8gY29yZS9yZWdpc3RyeS9uby1zdWNoLW1vZGVsLWVycm9yLnRzXG52YXIgTm9TdWNoTW9kZWxFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbW9kZWxJZCxcbiAgICBtb2RlbFR5cGUsXG4gICAgbWVzc2FnZSA9IGBObyBzdWNoICR7bW9kZWxUeXBlfTogJHttb2RlbElkfWBcbiAgfSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiQUlfTm9TdWNoTW9kZWxFcnJvclwiO1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5tb2RlbFR5cGUgPSBtb2RlbFR5cGU7XG4gIH1cbiAgc3RhdGljIGlzTm9TdWNoTW9kZWxFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IFwiQUlfTm9TdWNoTW9kZWxFcnJvclwiICYmIHR5cGVvZiBlcnJvci5tb2RlbElkID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci5tb2RlbFR5cGUgPT09IFwic3RyaW5nXCI7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIG1vZGVsSWQ6IHRoaXMubW9kZWxJZCxcbiAgICAgIG1vZGVsVHlwZTogdGhpcy5tb2RlbFR5cGVcbiAgICB9O1xuICB9XG59O1xuXG4vLyBjb3JlL3JlZ2lzdHJ5L25vLXN1Y2gtcHJvdmlkZXItZXJyb3IudHNcbnZhciBOb1N1Y2hQcm92aWRlckVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwcm92aWRlcklkLFxuICAgIGF2YWlsYWJsZVByb3ZpZGVycyxcbiAgICBtZXNzYWdlID0gYE5vIHN1Y2ggcHJvdmlkZXI6ICR7cHJvdmlkZXJJZH0gKGF2YWlsYWJsZSBwcm92aWRlcnM6ICR7YXZhaWxhYmxlUHJvdmlkZXJzLmpvaW4oKX0pYFxuICB9KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJBSV9Ob1N1Y2hQcm92aWRlckVycm9yXCI7XG4gICAgdGhpcy5wcm92aWRlcklkID0gcHJvdmlkZXJJZDtcbiAgICB0aGlzLmF2YWlsYWJsZVByb3ZpZGVycyA9IGF2YWlsYWJsZVByb3ZpZGVycztcbiAgfVxuICBzdGF0aWMgaXNOb1N1Y2hQcm92aWRlckVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gXCJBSV9Ob1N1Y2hQcm92aWRlckVycm9yXCIgJiYgdHlwZW9mIGVycm9yLnByb3ZpZGVySWQgPT09IFwic3RyaW5nXCIgJiYgQXJyYXkuaXNBcnJheShlcnJvci5hdmFpbGFibGVQcm92aWRlcnMpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBwcm92aWRlcklkOiB0aGlzLnByb3ZpZGVySWQsXG4gICAgICBhdmFpbGFibGVQcm92aWRlcnM6IHRoaXMuYXZhaWxhYmxlUHJvdmlkZXJzXG4gICAgfTtcbiAgfVxufTtcblxuLy8gY29yZS9yZWdpc3RyeS9wcm92aWRlci1yZWdpc3RyeS50c1xuZnVuY3Rpb24gZXhwZXJpbWVudGFsX2NyZWF0ZVByb3ZpZGVyUmVnaXN0cnkocHJvdmlkZXJzKSB7XG4gIGNvbnN0IHJlZ2lzdHJ5ID0gbmV3IERlZmF1bHRQcm92aWRlclJlZ2lzdHJ5KCk7XG4gIGZvciAoY29uc3QgW2lkLCBwcm92aWRlcl0gb2YgT2JqZWN0LmVudHJpZXMocHJvdmlkZXJzKSkge1xuICAgIHJlZ2lzdHJ5LnJlZ2lzdGVyUHJvdmlkZXIoeyBpZCwgcHJvdmlkZXIgfSk7XG4gIH1cbiAgcmV0dXJuIHJlZ2lzdHJ5O1xufVxudmFyIGV4cGVyaW1lbnRhbF9jcmVhdGVNb2RlbFJlZ2lzdHJ5ID0gZXhwZXJpbWVudGFsX2NyZWF0ZVByb3ZpZGVyUmVnaXN0cnk7XG52YXIgRGVmYXVsdFByb3ZpZGVyUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJvdmlkZXJzID0ge307XG4gIH1cbiAgcmVnaXN0ZXJQcm92aWRlcih7IGlkLCBwcm92aWRlciB9KSB7XG4gICAgdGhpcy5wcm92aWRlcnNbaWRdID0gcHJvdmlkZXI7XG4gIH1cbiAgZ2V0UHJvdmlkZXIoaWQpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMucHJvdmlkZXJzW2lkXTtcbiAgICBpZiAocHJvdmlkZXIgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaFByb3ZpZGVyRXJyb3Ioe1xuICAgICAgICBwcm92aWRlcklkOiBpZCxcbiAgICAgICAgYXZhaWxhYmxlUHJvdmlkZXJzOiBPYmplY3Qua2V5cyh0aGlzLnByb3ZpZGVycylcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdmlkZXI7XG4gIH1cbiAgc3BsaXRJZChpZCkge1xuICAgIGNvbnN0IGluZGV4ID0gaWQuaW5kZXhPZihcIjpcIik7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRNb2RlbElkRXJyb3IoeyBpZCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFtpZC5zbGljZSgwLCBpbmRleCksIGlkLnNsaWNlKGluZGV4ICsgMSldO1xuICB9XG4gIGxhbmd1YWdlTW9kZWwoaWQpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IFtwcm92aWRlcklkLCBtb2RlbElkXSA9IHRoaXMuc3BsaXRJZChpZCk7XG4gICAgY29uc3QgbW9kZWwgPSAoX2IgPSAoX2EgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQpKS5sYW5ndWFnZU1vZGVsKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yKHsgbW9kZWxJZDogaWQsIG1vZGVsVHlwZTogXCJsYW5ndWFnZSBtb2RlbFwiIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgdGV4dEVtYmVkZGluZ01vZGVsKGlkKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBbcHJvdmlkZXJJZCwgbW9kZWxJZF0gPSB0aGlzLnNwbGl0SWQoaWQpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9iID0gKF9hID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkKSkudGV4dEVtYmVkZGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIG1vZGVsSWQpO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcih7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGU6IFwidGV4dCBlbWJlZGRpbmcgbW9kZWxcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxufTtcblxuLy8gY29yZS90b29sL3Rvb2wudHNcbmZ1bmN0aW9uIHRvb2wodG9vbDIpIHtcbiAgcmV0dXJuIHRvb2wyO1xufVxuXG4vLyBjb3JlL3R5cGVzL2Vycm9ycy50c1xuaW1wb3J0IHtcbiAgQVBJQ2FsbEVycm9yIGFzIEFQSUNhbGxFcnJvcjIsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yIGFzIEludmFsaWRBcmd1bWVudEVycm9yMixcbiAgSW52YWxpZERhdGFDb250ZW50RXJyb3IgYXMgSW52YWxpZERhdGFDb250ZW50RXJyb3IyLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IgYXMgSW52YWxpZFByb21wdEVycm9yMixcbiAgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yLFxuICBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yIGFzIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IyLFxuICBKU09OUGFyc2VFcnJvcixcbiAgTG9hZEFQSUtleUVycm9yLFxuICBOb09iamVjdEdlbmVyYXRlZEVycm9yIGFzIE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IyLFxuICBOb1N1Y2hUb29sRXJyb3IgYXMgTm9TdWNoVG9vbEVycm9yMyxcbiAgUmV0cnlFcnJvciBhcyBSZXRyeUVycm9yMixcbiAgVG9vbENhbGxQYXJzZUVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcixcbiAgVW5zdXBwb3J0ZWRKU09OU2NoZW1hRXJyb3Jcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcblxuLy8gY29yZS91dGlsL2Nvc2luZS1zaW1pbGFyaXR5LnRzXG5mdW5jdGlvbiBjb3NpbmVTaW1pbGFyaXR5KHZlY3RvcjEsIHZlY3RvcjIpIHtcbiAgaWYgKHZlY3RvcjEubGVuZ3RoICE9PSB2ZWN0b3IyLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBWZWN0b3JzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGggKHZlY3RvcjE6ICR7dmVjdG9yMS5sZW5ndGh9IGVsZW1lbnRzLCB2ZWN0b3IyOiAke3ZlY3RvcjIubGVuZ3RofSBlbGVtZW50cylgXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZG90UHJvZHVjdCh2ZWN0b3IxLCB2ZWN0b3IyKSAvIChtYWduaXR1ZGUodmVjdG9yMSkgKiBtYWduaXR1ZGUodmVjdG9yMikpO1xufVxuZnVuY3Rpb24gZG90UHJvZHVjdCh2ZWN0b3IxLCB2ZWN0b3IyKSB7XG4gIHJldHVybiB2ZWN0b3IxLnJlZHVjZShcbiAgICAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCkgPT4gYWNjdW11bGF0b3IgKyB2YWx1ZSAqIHZlY3RvcjJbaW5kZXhdLFxuICAgIDBcbiAgKTtcbn1cbmZ1bmN0aW9uIG1hZ25pdHVkZSh2ZWN0b3IpIHtcbiAgcmV0dXJuIE1hdGguc3FydChkb3RQcm9kdWN0KHZlY3RvciwgdmVjdG9yKSk7XG59XG5cbi8vIHN0cmVhbXMvYWktc3RyZWFtLnRzXG5pbXBvcnQge1xuICBjcmVhdGVQYXJzZXJcbn0gZnJvbSBcImV2ZW50c291cmNlLXBhcnNlclwiO1xuZnVuY3Rpb24gY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcihjdXN0b21QYXJzZXIpIHtcbiAgY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgbGV0IGV2ZW50U291cmNlUGFyc2VyO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgZXZlbnRTb3VyY2VQYXJzZXIgPSBjcmVhdGVQYXJzZXIoXG4gICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgIGlmIChcImRhdGFcIiBpbiBldmVudCAmJiBldmVudC50eXBlID09PSBcImV2ZW50XCIgJiYgZXZlbnQuZGF0YSA9PT0gXCJbRE9ORV1cIiB8fCAvLyBSZXBsaWNhdGUgZG9lc24ndCBzZW5kIFtET05FXSBidXQgZG9lcyBzZW5kIGEgJ2RvbmUnIGV2ZW50XG4gICAgICAgICAgLy8gQHNlZSBodHRwczovL3JlcGxpY2F0ZS5jb20vZG9jcy9zdHJlYW1pbmdcbiAgICAgICAgICBldmVudC5ldmVudCA9PT0gXCJkb25lXCIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcImRhdGFcIiBpbiBldmVudCkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkTWVzc2FnZSA9IGN1c3RvbVBhcnNlciA/IGN1c3RvbVBhcnNlcihldmVudC5kYXRhLCB7XG4gICAgICAgICAgICAgIGV2ZW50OiBldmVudC5ldmVudFxuICAgICAgICAgICAgfSkgOiBldmVudC5kYXRhO1xuICAgICAgICAgICAgaWYgKHBhcnNlZE1lc3NhZ2UpXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJzZWRNZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICB0cmFuc2Zvcm0oY2h1bmspIHtcbiAgICAgIGV2ZW50U291cmNlUGFyc2VyLmZlZWQodGV4dERlY29kZXIuZGVjb2RlKGNodW5rKSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNiKSB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSBcIlwiO1xuICBjb25zdCBjYWxsYmFja3MgPSBjYiB8fCB7fTtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgaWYgKGNhbGxiYWNrcy5vblN0YXJ0KVxuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25TdGFydCgpO1xuICAgIH0sXG4gICAgYXN5bmMgdHJhbnNmb3JtKG1lc3NhZ2UsIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiBtZXNzYWdlLmNvbnRlbnQ7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dEVuY29kZXIuZW5jb2RlKGNvbnRlbnQpKTtcbiAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBjb250ZW50O1xuICAgICAgaWYgKGNhbGxiYWNrcy5vblRva2VuKVxuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Ub2tlbihjb250ZW50KTtcbiAgICAgIGlmIChjYWxsYmFja3Mub25UZXh0ICYmIHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vblRleHQobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBmbHVzaCgpIHtcbiAgICAgIGNvbnN0IGlzT3BlbkFJQ2FsbGJhY2tzID0gaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MoY2FsbGJhY2tzKTtcbiAgICAgIGlmIChjYWxsYmFja3Mub25Db21wbGV0aW9uKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkNvbXBsZXRpb24oYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbCAmJiAhaXNPcGVuQUlDYWxsYmFja3MpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MoY2FsbGJhY2tzKSB7XG4gIHJldHVybiBcImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbFwiIGluIGNhbGxiYWNrcztcbn1cbmZ1bmN0aW9uIHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCkge1xuICBsZXQgaXNTdHJlYW1TdGFydCA9IHRydWU7XG4gIHJldHVybiAodGV4dCkgPT4ge1xuICAgIGlmIChpc1N0cmVhbVN0YXJ0KSB7XG4gICAgICB0ZXh0ID0gdGV4dC50cmltU3RhcnQoKTtcbiAgICAgIGlmICh0ZXh0KVxuICAgICAgICBpc1N0cmVhbVN0YXJ0ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xufVxuZnVuY3Rpb24gQUlTdHJlYW0ocmVzcG9uc2UsIGN1c3RvbVBhcnNlciwgY2FsbGJhY2tzKSB7XG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICBpZiAocmVzcG9uc2UuYm9keSkge1xuICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcihgUmVzcG9uc2UgZXJyb3I6ICR7ZXJyb3JUZXh0fWApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IobmV3IEVycm9yKFwiUmVzcG9uc2UgZXJyb3I6IE5vIHJlc3BvbnNlIGJvZHlcIikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzcG9uc2VCb2R5U3RyZWFtID0gcmVzcG9uc2UuYm9keSB8fCBjcmVhdGVFbXB0eVJlYWRhYmxlU3RyZWFtKCk7XG4gIHJldHVybiByZXNwb25zZUJvZHlTdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcihjdXN0b21QYXJzZXIpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0oKSB7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShpdGVyYWJsZSkge1xuICBsZXQgaXQgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICBpZiAoZG9uZSlcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgZWxzZVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgIH0sXG4gICAgYXN5bmMgY2FuY2VsKHJlYXNvbikge1xuICAgICAgdmFyIF9hO1xuICAgICAgYXdhaXQgKChfYSA9IGl0LnJldHVybikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoaXQsIHJlYXNvbikpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHN0cmVhbXMvc3RyZWFtLWRhdGEudHNcbmltcG9ydCB7IGZvcm1hdFN0cmVhbVBhcnQgYXMgZm9ybWF0U3RyZWFtUGFydDIgfSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xudmFyIFN0cmVhbURhdGEgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIHRoaXMuY29udHJvbGxlciA9IG51bGw7XG4gICAgdGhpcy5pc0Nsb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMud2FybmluZ1RpbWVvdXQgPSBudWxsO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0OiBhc3luYyAoY29udHJvbGxlcikgPT4ge1xuICAgICAgICBzZWxmLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgIHNlbGYud2FybmluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgXCJUaGUgZGF0YSBzdHJlYW0gaXMgaGFuZ2luZy4gRGlkIHlvdSBmb3JnZXQgdG8gY2xvc2UgaXQgd2l0aCBgZGF0YS5jbG9zZSgpYD9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LCAzZTMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHVsbDogKGNvbnRyb2xsZXIpID0+IHtcbiAgICAgIH0sXG4gICAgICBjYW5jZWw6IChyZWFzb24pID0+IHtcbiAgICAgICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbnRyb2xsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC5cIik7XG4gICAgfVxuICAgIHRoaXMuY29udHJvbGxlci5jbG9zZSgpO1xuICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLndhcm5pbmdUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy53YXJuaW5nVGltZW91dCk7XG4gICAgfVxuICB9XG4gIGFwcGVuZCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cIik7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gY29udHJvbGxlciBpcyBub3QgaW5pdGlhbGl6ZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDIoXCJkYXRhXCIsIFt2YWx1ZV0pKVxuICAgICk7XG4gIH1cbiAgYXBwZW5kTWVzc2FnZUFubm90YXRpb24odmFsdWUpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb250cm9sbGVyLmVucXVldWUoXG4gICAgICB0aGlzLmVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQyKFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiLCBbdmFsdWVdKSlcbiAgICApO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkge1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZGVjb2Rlci5kZWNvZGUoY2h1bmspO1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQyKFwidGV4dFwiLCBtZXNzYWdlKSkpO1xuICAgIH1cbiAgfSk7XG59XG52YXIgZXhwZXJpbWVudGFsX1N0cmVhbURhdGEgPSBjbGFzcyBleHRlbmRzIFN0cmVhbURhdGEge1xufTtcblxuLy8gc3RyZWFtcy9hbnRocm9waWMtc3RyZWFtLnRzXG5mdW5jdGlvbiBwYXJzZUFudGhyb3BpY1N0cmVhbSgpIHtcbiAgbGV0IHByZXZpb3VzID0gXCJcIjtcbiAgcmV0dXJuIChkYXRhKSA9PiB7XG4gICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgaWYgKFwiZXJyb3JcIiBpbiBqc29uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7anNvbi5lcnJvci50eXBlfTogJHtqc29uLmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIGlmICghKFwiY29tcGxldGlvblwiIGluIGpzb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSBqc29uLmNvbXBsZXRpb247XG4gICAgaWYgKCFwcmV2aW91cyB8fCB0ZXh0Lmxlbmd0aCA+IHByZXZpb3VzLmxlbmd0aCAmJiB0ZXh0LnN0YXJ0c1dpdGgocHJldmlvdXMpKSB7XG4gICAgICBjb25zdCBkZWx0YSA9IHRleHQuc2xpY2UocHJldmlvdXMubGVuZ3RoKTtcbiAgICAgIHByZXZpb3VzID0gdGV4dDtcbiAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZShzdHJlYW0pIHtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBpZiAoXCJjb21wbGV0aW9uXCIgaW4gY2h1bmspIHtcbiAgICAgIGNvbnN0IHRleHQgPSBjaHVuay5jb21wbGV0aW9uO1xuICAgICAgaWYgKHRleHQpXG4gICAgICAgIHlpZWxkIHRleHQ7XG4gICAgfSBlbHNlIGlmIChcImRlbHRhXCIgaW4gY2h1bmspIHtcbiAgICAgIGNvbnN0IHsgZGVsdGEgfSA9IGNodW5rO1xuICAgICAgaWYgKFwidGV4dFwiIGluIGRlbHRhKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSBkZWx0YS50ZXh0O1xuICAgICAgICBpZiAodGV4dClcbiAgICAgICAgICB5aWVsZCB0ZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gQW50aHJvcGljU3RyZWFtKHJlcywgY2IpIHtcbiAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHJlcykge1xuICAgIHJldHVybiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGUocmVzKSkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2IpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFJU3RyZWFtKHJlcywgcGFyc2VBbnRocm9waWNTdHJlYW0oKSwgY2IpLnBpcGVUaHJvdWdoKFxuICAgICAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKClcbiAgICApO1xuICB9XG59XG5cbi8vIHN0cmVhbXMvYXNzaXN0YW50LXJlc3BvbnNlLnRzXG5pbXBvcnQge1xuICBmb3JtYXRTdHJlYW1QYXJ0IGFzIGZvcm1hdFN0cmVhbVBhcnQzXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5mdW5jdGlvbiBBc3Npc3RhbnRSZXNwb25zZSh7IHRocmVhZElkLCBtZXNzYWdlSWQgfSwgcHJvY2VzczIpIHtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgY29uc3Qgc2VuZE1lc3NhZ2UgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQzKFwiYXNzaXN0YW50X21lc3NhZ2VcIiwgbWVzc2FnZSkpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2VuZERhdGFNZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0MyhcImRhdGFfbWVzc2FnZVwiLCBtZXNzYWdlKSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzZW5kRXJyb3IgPSAoZXJyb3JNZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDMoXCJlcnJvclwiLCBlcnJvck1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGZvcndhcmRTdHJlYW0gPSBhc3luYyAoc3RyZWFtMikgPT4ge1xuICAgICAgICB2YXIgX2EyLCBfYjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBzdHJlYW0yKSB7XG4gICAgICAgICAgc3dpdGNoICh2YWx1ZS5ldmVudCkge1xuICAgICAgICAgICAgY2FzZSBcInRocmVhZC5tZXNzYWdlLmNyZWF0ZWRcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydDMoXCJhc3Npc3RhbnRfbWVzc2FnZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB2YWx1ZS5kYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogeyB2YWx1ZTogXCJcIiB9IH1dXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGhyZWFkLm1lc3NhZ2UuZGVsdGFcIjoge1xuICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gKF9hMiA9IHZhbHVlLmRhdGEuZGVsdGEuY29udGVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMlswXTtcbiAgICAgICAgICAgICAgaWYgKChjb250ZW50ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZW50LnR5cGUpID09PSBcInRleHRcIiAmJiAoKF9iID0gY29udGVudC50ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2IudmFsdWUpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQzKFwidGV4dFwiLCBjb250ZW50LnRleHQudmFsdWUpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0aHJlYWQucnVuLmNvbXBsZXRlZFwiOlxuICAgICAgICAgICAgY2FzZSBcInRocmVhZC5ydW4ucmVxdWlyZXNfYWN0aW9uXCI6IHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUuZGF0YTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgZm9ybWF0U3RyZWFtUGFydDMoXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsIHtcbiAgICAgICAgICAgIHRocmVhZElkLFxuICAgICAgICAgICAgbWVzc2FnZUlkXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHByb2Nlc3MyKHtcbiAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICBtZXNzYWdlSWQsXG4gICAgICAgICAgc2VuZE1lc3NhZ2UsXG4gICAgICAgICAgc2VuZERhdGFNZXNzYWdlLFxuICAgICAgICAgIGZvcndhcmRTdHJlYW1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzZW5kRXJyb3IoKF9hID0gZXJyb3IubWVzc2FnZSkgIT0gbnVsbCA/IF9hIDogYCR7ZXJyb3J9YCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICB9LFxuICAgIGNhbmNlbCgpIHtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHN0cmVhbSwge1xuICAgIHN0YXR1czogMjAwLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgfVxuICB9KTtcbn1cbnZhciBleHBlcmltZW50YWxfQXNzaXN0YW50UmVzcG9uc2UgPSBBc3Npc3RhbnRSZXNwb25zZTtcblxuLy8gc3RyZWFtcy9hd3MtYmVkcm9jay1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uKiBhc0RlbHRhSXRlcmFibGUocmVzcG9uc2UsIGV4dHJhY3RUZXh0RGVsdGFGcm9tQ2h1bmspIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIChfYSA9IHJlc3BvbnNlLmJvZHkpICE9IG51bGwgPyBfYSA6IFtdKSB7XG4gICAgY29uc3QgYnl0ZXMgPSAoX2IgPSBjaHVuay5jaHVuaykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmJ5dGVzO1xuICAgIGlmIChieXRlcyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBjaHVua1RleHQgPSBkZWNvZGVyLmRlY29kZShieXRlcyk7XG4gICAgICBjb25zdCBjaHVua0pTT04gPSBKU09OLnBhcnNlKGNodW5rVGV4dCk7XG4gICAgICBjb25zdCBkZWx0YSA9IGV4dHJhY3RUZXh0RGVsdGFGcm9tQ2h1bmsoY2h1bmtKU09OKTtcbiAgICAgIGlmIChkZWx0YSAhPSBudWxsKSB7XG4gICAgICAgIHlpZWxkIGRlbHRhO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gQVdTQmVkcm9ja0FudGhyb3BpY01lc3NhZ2VzU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIEFXU0JlZHJvY2tTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcywgKGNodW5rKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSBjaHVuay5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRleHQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gQVdTQmVkcm9ja0FudGhyb3BpY1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBBV1NCZWRyb2NrU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MsIChjaHVuaykgPT4gY2h1bmsuY29tcGxldGlvbik7XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrQ29oZXJlU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIEFXU0JlZHJvY2tTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcywgKGNodW5rKSA9PiBjaHVuayA9PSBudWxsID8gdm9pZCAwIDogY2h1bmsudGV4dCk7XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrTGxhbWEyU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIEFXU0JlZHJvY2tTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcywgKGNodW5rKSA9PiBjaHVuay5nZW5lcmF0aW9uKTtcbn1cbmZ1bmN0aW9uIEFXU0JlZHJvY2tTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcywgZXh0cmFjdFRleHREZWx0YUZyb21DaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShcbiAgICBhc0RlbHRhSXRlcmFibGUocmVzcG9uc2UsIGV4dHJhY3RUZXh0RGVsdGFGcm9tQ2h1bmspXG4gICkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuXG4vLyBzdHJlYW1zL2NvaGVyZS1zdHJlYW0udHNcbnZhciB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0xpbmVzKGxpbmVzLCBjb250cm9sbGVyKSB7XG4gIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgIGNvbnN0IHsgdGV4dCwgaXNfZmluaXNoZWQgfSA9IEpTT04ucGFyc2UobGluZSk7XG4gICAgaWYgKCFpc19maW5pc2hlZCkge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHQpO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmVhZEFuZFByb2Nlc3NMaW5lcyhyZWFkZXIsIGNvbnRyb2xsZXIpIHtcbiAgbGV0IHNlZ21lbnQgPSBcIlwiO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgdmFsdWU6IGNodW5rLCBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2VnbWVudCArPSB1dGY4RGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIGNvbnN0IGxpbmVzQXJyYXkgPSBzZWdtZW50LnNwbGl0KC9cXHJcXG58XFxufFxcci9nKTtcbiAgICBzZWdtZW50ID0gbGluZXNBcnJheS5wb3AoKSB8fCBcIlwiO1xuICAgIGF3YWl0IHByb2Nlc3NMaW5lcyhsaW5lc0FycmF5LCBjb250cm9sbGVyKTtcbiAgfVxuICBpZiAoc2VnbWVudCkge1xuICAgIGNvbnN0IGxpbmVzQXJyYXkgPSBbc2VnbWVudF07XG4gICAgYXdhaXQgcHJvY2Vzc0xpbmVzKGxpbmVzQXJyYXksIGNvbnRyb2xsZXIpO1xuICB9XG4gIGNvbnRyb2xsZXIuY2xvc2UoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlcjIocmVzKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgcmVhZGVyID0gKF9hID0gcmVzLmJvZHkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5nZXRSZWFkZXIoKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgaWYgKCFyZWFkZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCByZWFkQW5kUHJvY2Vzc0xpbmVzKHJlYWRlciwgY29udHJvbGxlcik7XG4gICAgfVxuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlMihzdHJlYW0pIHtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBpZiAoY2h1bmsuZXZlbnRUeXBlID09PSBcInRleHQtZ2VuZXJhdGlvblwiKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gY2h1bmsudGV4dDtcbiAgICAgIGlmICh0ZXh0KVxuICAgICAgICB5aWVsZCB0ZXh0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gQ29oZXJlU3RyZWFtKHJlYWRlciwgY2FsbGJhY2tzKSB7XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZWFkZXIpIHtcbiAgICByZXR1cm4gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlMihyZWFkZXIpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhcnNlcjIocmVhZGVyKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH1cbn1cblxuLy8gc3RyZWFtcy9nb29nbGUtZ2VuZXJhdGl2ZS1haS1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlMyhyZXNwb25zZSkge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZXNwb25zZS5zdHJlYW0pIHtcbiAgICBjb25zdCBwYXJ0cyA9IChfYyA9IChfYiA9IChfYSA9IGNodW5rLmNhbmRpZGF0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYy5wYXJ0cztcbiAgICBpZiAocGFydHMgPT09IHZvaWQgMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UGFydCA9IHBhcnRzWzBdO1xuICAgIGlmICh0eXBlb2YgZmlyc3RQYXJ0LnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHlpZWxkIGZpcnN0UGFydC50ZXh0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gR29vZ2xlR2VuZXJhdGl2ZUFJU3RyZWFtKHJlc3BvbnNlLCBjYikge1xuICByZXR1cm4gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlMyhyZXNwb25zZSkpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNiKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuXG4vLyBzdHJlYW1zL2h1Z2dpbmdmYWNlLXN0cmVhbS50c1xuZnVuY3Rpb24gY3JlYXRlUGFyc2VyMyhyZXMpIHtcbiAgY29uc3QgdHJpbVN0YXJ0T2ZTdHJlYW0gPSB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCByZXMubmV4dCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0ID0gdHJpbVN0YXJ0T2ZTdHJlYW0oKF9iID0gKF9hID0gdmFsdWUudG9rZW4pID09IG51bGwgPyB2b2lkIDAgOiBfYS50ZXh0KSAhPSBudWxsID8gX2IgOiBcIlwiKTtcbiAgICAgIGlmICghdGV4dClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHZhbHVlLmdlbmVyYXRlZF90ZXh0ICE9IG51bGwgJiYgdmFsdWUuZ2VuZXJhdGVkX3RleHQubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGV4dCA9PT0gXCI8L3M+XCIgfHwgdGV4dCA9PT0gXCI8fGVuZG9mdGV4dHw+XCIgfHwgdGV4dCA9PT0gXCI8fGVuZHw+XCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHQpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBIdWdnaW5nRmFjZVN0cmVhbShyZXMsIGNhbGxiYWNrcykge1xuICByZXR1cm4gY3JlYXRlUGFyc2VyMyhyZXMpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbn1cblxuLy8gc3RyZWFtcy9pbmtlZXAtc3RyZWFtLnRzXG5mdW5jdGlvbiBJbmtlZXBTdHJlYW0ocmVzLCBjYWxsYmFja3MpIHtcbiAgaWYgKCFyZXMuYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIGJvZHkgaXMgbnVsbFwiKTtcbiAgfVxuICBsZXQgY2hhdF9zZXNzaW9uX2lkID0gXCJcIjtcbiAgbGV0IHJlY29yZHNfY2l0ZWQ7XG4gIGNvbnN0IGlua2VlcEV2ZW50UGFyc2VyID0gKGRhdGEsIG9wdGlvbnMpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgZXZlbnQgfSA9IG9wdGlvbnM7XG4gICAgaWYgKGV2ZW50ID09PSBcInJlY29yZHNfY2l0ZWRcIikge1xuICAgICAgcmVjb3Jkc19jaXRlZCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAoX2EgPSBjYWxsYmFja3MgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblJlY29yZHNDaXRlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoY2FsbGJhY2tzLCByZWNvcmRzX2NpdGVkKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50ID09PSBcIm1lc3NhZ2VfY2h1bmtcIikge1xuICAgICAgY29uc3QgaW5rZWVwTWVzc2FnZUNodW5rID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIGNoYXRfc2Vzc2lvbl9pZCA9IChfYiA9IGlua2VlcE1lc3NhZ2VDaHVuay5jaGF0X3Nlc3Npb25faWQpICE9IG51bGwgPyBfYiA6IGNoYXRfc2Vzc2lvbl9pZDtcbiAgICAgIHJldHVybiBpbmtlZXBNZXNzYWdlQ2h1bmsuY29udGVudF9jaHVuaztcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9O1xuICBsZXQgeyBvblJlY29yZHNDaXRlZCwgLi4ucGFzc1Rocm91Z2hDYWxsYmFja3MgfSA9IGNhbGxiYWNrcyB8fCB7fTtcbiAgcGFzc1Rocm91Z2hDYWxsYmFja3MgPSB7XG4gICAgLi4ucGFzc1Rocm91Z2hDYWxsYmFja3MsXG4gICAgb25GaW5hbDogKGNvbXBsZXRpb24pID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGlua2VlcE9uRmluYWxNZXRhZGF0YSA9IHtcbiAgICAgICAgY2hhdF9zZXNzaW9uX2lkLFxuICAgICAgICByZWNvcmRzX2NpdGVkXG4gICAgICB9O1xuICAgICAgKF9hID0gY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25GaW5hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoY2FsbGJhY2tzLCBjb21wbGV0aW9uLCBpbmtlZXBPbkZpbmFsTWV0YWRhdGEpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEFJU3RyZWFtKHJlcywgaW5rZWVwRXZlbnRQYXJzZXIsIHBhc3NUaHJvdWdoQ2FsbGJhY2tzKS5waXBlVGhyb3VnaChcbiAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKVxuICApO1xufVxuXG4vLyBzdHJlYW1zL2xhbmdjaGFpbi1hZGFwdGVyLnRzXG52YXIgbGFuZ2NoYWluX2FkYXB0ZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobGFuZ2NoYWluX2FkYXB0ZXJfZXhwb3J0cywge1xuICB0b0FJU3RyZWFtOiAoKSA9PiB0b0FJU3RyZWFtXG59KTtcbmZ1bmN0aW9uIHRvQUlTdHJlYW0oc3RyZWFtLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuay5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLmNvbnRlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBjaHVuay5jb250ZW50O1xuICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoaXRlbS50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICApLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbn1cblxuLy8gc3RyZWFtcy9sYW5nY2hhaW4tc3RyZWFtLnRzXG5mdW5jdGlvbiBMYW5nQ2hhaW5TdHJlYW0oY2FsbGJhY2tzKSB7XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oKTtcbiAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICBjb25zdCBydW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgaGFuZGxlRXJyb3IgPSBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICBydW5zLmRlbGV0ZShydW5JZCk7XG4gICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgIGF3YWl0IHdyaXRlci5hYm9ydChlKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlU3RhcnQgPSBhc3luYyAocnVuSWQpID0+IHtcbiAgICBydW5zLmFkZChydW5JZCk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZUVuZCA9IGFzeW5jIChydW5JZCkgPT4ge1xuICAgIHJ1bnMuZGVsZXRlKHJ1bklkKTtcbiAgICBpZiAocnVucy5zaXplID09PSAwKSB7XG4gICAgICBhd2FpdCB3cml0ZXIucmVhZHk7XG4gICAgICBhd2FpdCB3cml0ZXIuY2xvc2UoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiBzdHJlYW0ucmVhZGFibGUucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpLFxuICAgIHdyaXRlcixcbiAgICBoYW5kbGVyczoge1xuICAgICAgaGFuZGxlTExNTmV3VG9rZW46IGFzeW5jICh0b2tlbikgPT4ge1xuICAgICAgICBhd2FpdCB3cml0ZXIucmVhZHk7XG4gICAgICAgIGF3YWl0IHdyaXRlci53cml0ZSh0b2tlbik7XG4gICAgICB9LFxuICAgICAgaGFuZGxlTExNU3RhcnQ6IGFzeW5jIChfbGxtLCBfcHJvbXB0cywgcnVuSWQpID0+IHtcbiAgICAgICAgaGFuZGxlU3RhcnQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUxMTUVuZDogYXN5bmMgKF9vdXRwdXQsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVuZChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlTExNRXJyb3I6IGFzeW5jIChlLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihlLCBydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlQ2hhaW5TdGFydDogYXN5bmMgKF9jaGFpbiwgX2lucHV0cywgcnVuSWQpID0+IHtcbiAgICAgICAgaGFuZGxlU3RhcnQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUNoYWluRW5kOiBhc3luYyAoX291dHB1dHMsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVuZChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlQ2hhaW5FcnJvcjogYXN5bmMgKGUsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKGUsIHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVUb29sU3RhcnQ6IGFzeW5jIChfdG9vbCwgX2lucHV0LCBydW5JZCkgPT4ge1xuICAgICAgICBoYW5kbGVTdGFydChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlVG9vbEVuZDogYXN5bmMgKF9vdXRwdXQsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVuZChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlVG9vbEVycm9yOiBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IoZSwgcnVuSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gc3RyZWFtcy9taXN0cmFsLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGU0KHN0cmVhbSkge1xuICB2YXIgX2EsIF9iO1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSAoX2IgPSAoX2EgPSBjaHVuay5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jb250ZW50O1xuICAgIGlmIChjb250ZW50ID09PSB2b2lkIDAgfHwgY29udGVudCA9PT0gXCJcIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHlpZWxkIGNvbnRlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIE1pc3RyYWxTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICBjb25zdCBzdHJlYW0gPSByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGU0KHJlc3BvbnNlKSk7XG4gIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuXG4vLyBzdHJlYW1zL29wZW5haS1zdHJlYW0udHNcbmltcG9ydCB7XG4gIGNyZWF0ZUNodW5rRGVjb2RlcixcbiAgZm9ybWF0U3RyZWFtUGFydCBhcyBmb3JtYXRTdHJlYW1QYXJ0NFxufSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuZnVuY3Rpb24gcGFyc2VPcGVuQUlTdHJlYW0oKSB7XG4gIGNvbnN0IGV4dHJhY3QgPSBjaHVua1RvVGV4dCgpO1xuICByZXR1cm4gKGRhdGEpID0+IGV4dHJhY3QoSlNPTi5wYXJzZShkYXRhKSk7XG59XG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZTUoc3RyZWFtKSB7XG4gIGNvbnN0IGV4dHJhY3QgPSBjaHVua1RvVGV4dCgpO1xuICBmb3IgYXdhaXQgKGxldCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBpZiAoXCJwcm9tcHRGaWx0ZXJSZXN1bHRzXCIgaW4gY2h1bmspIHtcbiAgICAgIGNodW5rID0ge1xuICAgICAgICBpZDogY2h1bmsuaWQsXG4gICAgICAgIGNyZWF0ZWQ6IGNodW5rLmNyZWF0ZWQuZ2V0RGF0ZSgpLFxuICAgICAgICBvYmplY3Q6IGNodW5rLm9iamVjdCxcbiAgICAgICAgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIG1vZGVsOiBjaHVuay5tb2RlbCxcbiAgICAgICAgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIGNob2ljZXM6IGNodW5rLmNob2ljZXMubWFwKChjaG9pY2UpID0+IHtcbiAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbHRhOiB7XG4gICAgICAgICAgICAgIGNvbnRlbnQ6IChfYSA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNvbnRlbnQsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uX2NhbGw6IChfYiA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgICAgICAgcm9sZTogKF9jID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2Mucm9sZSxcbiAgICAgICAgICAgICAgdG9vbF9jYWxsczogKChfZSA9IChfZCA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmxlbmd0aCkgPyAoX2cgPSAoX2YgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfZi50b29sQ2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfZy5tYXAoKHRvb2xDYWxsLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb246IHRvb2xDYWxsLmZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHR5cGU6IHRvb2xDYWxsLnR5cGVcbiAgICAgICAgICAgICAgfSkpIDogdm9pZCAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmluaXNoX3JlYXNvbjogY2hvaWNlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIGluZGV4OiBjaG9pY2UuaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IGV4dHJhY3QoY2h1bmspO1xuICAgIGlmICh0ZXh0KVxuICAgICAgeWllbGQgdGV4dDtcbiAgfVxufVxuZnVuY3Rpb24gY2h1bmtUb1RleHQoKSB7XG4gIGNvbnN0IHRyaW1TdGFydE9mU3RyZWFtID0gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKTtcbiAgbGV0IGlzRnVuY3Rpb25TdHJlYW1pbmdJbjtcbiAgcmV0dXJuIChqc29uKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2ksIF9qLCBfaywgX2wsIF9tLCBfbiwgX28sIF9wLCBfcSwgX3I7XG4gICAgaWYgKGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSkge1xuICAgICAgY29uc3QgZGVsdGEgPSAoX2EgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5kZWx0YTtcbiAgICAgIGlmICgoX2IgPSBkZWx0YS5mdW5jdGlvbl9jYWxsKSA9PSBudWxsID8gdm9pZCAwIDogX2IubmFtZSkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogYHtcImZ1bmN0aW9uX2NhbGxcIjoge1wibmFtZVwiOiBcIiR7ZGVsdGEuZnVuY3Rpb25fY2FsbC5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImBcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKF9lID0gKF9kID0gKF9jID0gZGVsdGEudG9vbF9jYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2QuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZS5uYW1lKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsID0gZGVsdGEudG9vbF9jYWxsc1swXTtcbiAgICAgICAgaWYgKHRvb2xDYWxsLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgICBjb250ZW50OiBge1widG9vbF9jYWxsc1wiOlsge1wiaWRcIjogXCIke3Rvb2xDYWxsLmlkfVwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCIkeyhfZiA9IHRvb2xDYWxsLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2YubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGBcIn19LCB7XCJpZFwiOiBcIiR7dG9vbENhbGwuaWR9XCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIiR7KF9nID0gdG9vbENhbGwuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZy5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChfaCA9IGRlbHRhLmZ1bmN0aW9uX2NhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfaC5hcmd1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGNsZWFudXBBcmd1bWVudHMoKF9pID0gZGVsdGEuZnVuY3Rpb25fY2FsbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pLmFyZ3VtZW50cylcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKF9sID0gKF9rID0gKF9qID0gZGVsdGEudG9vbF9jYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9qWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2suZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfbC5hcmd1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGNsZWFudXBBcmd1bWVudHMoKF9vID0gKF9uID0gKF9tID0gZGVsdGEudG9vbF9jYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9tWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX24uZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfby5hcmd1bWVudHMpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJiAoKChfcCA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wLmZpbmlzaF9yZWFzb24pID09PSBcImZ1bmN0aW9uX2NhbGxcIiB8fCAoKF9xID0ganNvbi5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3EuZmluaXNoX3JlYXNvbikgPT09IFwic3RvcFwiKSkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6ICdcIn19J1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiYgKChfciA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yLmZpbmlzaF9yZWFzb24pID09PSBcInRvb2xfY2FsbHNcIikge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6ICdcIn19XX0nXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSB0cmltU3RhcnRPZlN0cmVhbShcbiAgICAgIGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSAmJiBqc29uLmNob2ljZXNbMF0uZGVsdGEuY29udGVudCA/IGpzb24uY2hvaWNlc1swXS5kZWx0YS5jb250ZW50IDogaXNDb21wbGV0aW9uKGpzb24pID8ganNvbi5jaG9pY2VzWzBdLnRleHQgOiBcIlwiXG4gICAgKTtcbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbiAgZnVuY3Rpb24gY2xlYW51cEFyZ3VtZW50cyhhcmd1bWVudENodW5rKSB7XG4gICAgbGV0IGVzY2FwZWRQYXJ0aWFsSnNvbiA9IGFyZ3VtZW50Q2h1bmsucmVwbGFjZSgvXFxcXC9nLCBcIlxcXFxcXFxcXCIpLnJlcGxhY2UoL1xcLy9nLCBcIlxcXFwvXCIpLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKS5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKS5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKS5yZXBsYWNlKC9cXGYvZywgXCJcXFxcZlwiKTtcbiAgICByZXR1cm4gYCR7ZXNjYXBlZFBhcnRpYWxKc29ufWA7XG4gIH1cbn1cbnZhciBfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sID0gU3ltYm9sKFxuICBcImludGVybmFsX29wZW5haV9mbl9tZXNzYWdlc1wiXG4pO1xuZnVuY3Rpb24gaXNDaGF0Q29tcGxldGlvbkNodW5rKGRhdGEpIHtcbiAgcmV0dXJuIFwiY2hvaWNlc1wiIGluIGRhdGEgJiYgZGF0YS5jaG9pY2VzICYmIGRhdGEuY2hvaWNlc1swXSAmJiBcImRlbHRhXCIgaW4gZGF0YS5jaG9pY2VzWzBdO1xufVxuZnVuY3Rpb24gaXNDb21wbGV0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIFwiY2hvaWNlc1wiIGluIGRhdGEgJiYgZGF0YS5jaG9pY2VzICYmIGRhdGEuY2hvaWNlc1swXSAmJiBcInRleHRcIiBpbiBkYXRhLmNob2ljZXNbMF07XG59XG5mdW5jdGlvbiBPcGVuQUlTdHJlYW0ocmVzLCBjYWxsYmFja3MpIHtcbiAgY29uc3QgY2IgPSBjYWxsYmFja3M7XG4gIGxldCBzdHJlYW07XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZXMpIHtcbiAgICBzdHJlYW0gPSByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGU1KHJlcykpLnBpcGVUaHJvdWdoKFxuICAgICAgY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoXG4gICAgICAgIChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB8fCAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSA/IHtcbiAgICAgICAgICAuLi5jYixcbiAgICAgICAgICBvbkZpbmFsOiB2b2lkIDBcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAuLi5jYlxuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0gPSBBSVN0cmVhbShcbiAgICAgIHJlcyxcbiAgICAgIHBhcnNlT3BlbkFJU3RyZWFtKCksXG4gICAgICAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkgfHwgKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkgPyB7XG4gICAgICAgIC4uLmNiLFxuICAgICAgICBvbkZpbmFsOiB2b2lkIDBcbiAgICAgIH0gOiB7XG4gICAgICAgIC4uLmNiXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBpZiAoY2IgJiYgKGNiLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fCBjYi5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkpIHtcbiAgICBjb25zdCBmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lciA9IGNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKGNiKTtcbiAgICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKGZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gXCJcIjtcbiAgbGV0IGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSA9IFwiXCI7XG4gIGxldCBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gY2FsbGJhY2tzW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdIHx8IFtdO1xuICBjb25zdCBkZWNvZGUgPSBjcmVhdGVDaHVua0RlY29kZXIoKTtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGRlY29kZShjaHVuayk7XG4gICAgICBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgIGNvbnN0IHNob3VsZEhhbmRsZUFzRnVuY3Rpb24gPSBpc0ZpcnN0Q2h1bmsgJiYgKG1lc3NhZ2Uuc3RhcnRzV2l0aCgne1wiZnVuY3Rpb25fY2FsbFwiOicpIHx8IG1lc3NhZ2Uuc3RhcnRzV2l0aCgne1widG9vbF9jYWxsc1wiOicpKTtcbiAgICAgIGlmIChzaG91bGRIYW5kbGVBc0Z1bmN0aW9uKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgICBpc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0Z1bmN0aW9uU3RyZWFtaW5nSW4pIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0NChcInRleHRcIiwgbWVzc2FnZSkpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFpc0ZpcnN0Q2h1bmsgJiYgaXNGdW5jdGlvblN0cmVhbWluZ0luICYmIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8IGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkpIHtcbiAgICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgICAgIGxldCBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgIC4uLmZ1bmN0aW9uQ2FsbE1lc3NhZ2VzXG4gICAgICAgICAgXTtcbiAgICAgICAgICBsZXQgZnVuY3Rpb25SZXNwb25zZSA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgICAgaWYgKHBheWxvYWQuZnVuY3Rpb25fY2FsbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBcImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29sc1wiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcmd1bWVudHNQYXlsb2FkID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgcGF5bG9hZC5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50c1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBhcmd1bWVudHNQYXlsb2FkXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgICAgICAgIC4uLmZ1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHJlc3VsdClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGxzID0ge1xuICAgICAgICAgICAgICB0b29sczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2wyIG9mIHBheWxvYWQudG9vbF9jYWxscykge1xuICAgICAgICAgICAgICB0b29sQ2FsbHMudG9vbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IHRvb2wyLmlkLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBmdW5jOiB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiB0b29sMi5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnBhcnNlKHRvb2wyLmZ1bmN0aW9uLmFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlSW5kZXggPSAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZSA9IGF3YWl0IGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbChcbiAgICAgICAgICAgICAgICB0b29sQ2FsbHMsXG4gICAgICAgICAgICAgICAgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRvb2xfY2FsbF9pZCwgZnVuY3Rpb25fbmFtZSwgdG9vbF9jYWxsX3Jlc3VsdCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5uZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFwcGVuZCB0aGUgYXNzaXN0YW50IG1lc3NhZ2UgaWYgaXQncyB0aGUgZmlyc3QgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAuLi5yZXNwb25zZUluZGV4ID09PSAwID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGxzOiBwYXlsb2FkLnRvb2xfY2FsbHMubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0YykgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0Yy5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRjLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHNlbmQgdGhlIGFyZ3VtZW50cyBhbiBvYmplY3QgdG8gdGhlIHVzZXIsIGJ1dCBhcyB0aGUgQVBJIGV4cGVjdHMgYSBzdHJpbmcsIHdlIG5lZWQgdG8gc3RyaW5naWZ5IGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGMuZnVuY3Rpb24uYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgXSA6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgZnVuY3Rpb24gY2FsbCByZXN1bHQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25fbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHRvb2xfY2FsbF9yZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2FsbGluZyBleHBlcmltZW50YWxfb25Ub29sQ2FsbDpcIiwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZnVuY3Rpb25SZXNwb25zZSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydDQoXG4gICAgICAgICAgICAgICAgICBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwgPyBcImZ1bmN0aW9uX2NhbGxcIiA6IFwidG9vbF9jYWxsc1wiLFxuICAgICAgICAgICAgICAgICAgLy8gcGFyc2UgdG8gcHJldmVudCBkb3VibGUtZW5jb2Rpbmc6XG4gICAgICAgICAgICAgICAgICBKU09OLnBhcnNlKGFnZ3JlZ2F0ZWRSZXNwb25zZSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZnVuY3Rpb25SZXNwb25zZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDQoXCJ0ZXh0XCIsIGZ1bmN0aW9uUmVzcG9uc2UpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSA9IGZ1bmN0aW9uUmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkQ2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgLi4uY2FsbGJhY2tzLFxuICAgICAgICAgICAgb25TdGFydDogdm9pZCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjYWxsYmFja3Mub25GaW5hbCA9IHZvaWQgMDtcbiAgICAgICAgICBjb25zdCBvcGVuQUlTdHJlYW0gPSBPcGVuQUlTdHJlYW0oZnVuY3Rpb25SZXNwb25zZSwge1xuICAgICAgICAgICAgLi4uZmlsdGVyZWRDYWxsYmFja3MsXG4gICAgICAgICAgICBbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF06IG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgcmVhZGVyID0gb3BlbkFJU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsICYmIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSkge1xuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzdHJlYW1zL3JlcGxpY2F0ZS1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uIFJlcGxpY2F0ZVN0cmVhbShyZXMsIGNiLCBvcHRpb25zKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgdXJsID0gKF9hID0gcmVzLnVybHMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zdHJlYW07XG4gIGlmICghdXJsKSB7XG4gICAgaWYgKHJlcy5lcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXMuZXJyb3IpO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgc3RyZWFtIFVSTCBpbiBSZXBsaWNhdGUgcmVzcG9uc2VcIik7XG4gIH1cbiAgY29uc3QgZXZlbnRTdHJlYW0gPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgQWNjZXB0OiBcInRleHQvZXZlbnQtc3RyZWFtXCIsXG4gICAgICAuLi5vcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnNcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gQUlTdHJlYW0oZXZlbnRTdHJlYW0sIHZvaWQgMCwgY2IpLnBpcGVUaHJvdWdoKFxuICAgIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpXG4gICk7XG59XG5cbi8vIGNvcmUvdXRpbC9tZXJnZS1zdHJlYW1zLnRzXG5mdW5jdGlvbiBtZXJnZVN0cmVhbXMoc3RyZWFtMSwgc3RyZWFtMikge1xuICBjb25zdCByZWFkZXIxID0gc3RyZWFtMS5nZXRSZWFkZXIoKTtcbiAgY29uc3QgcmVhZGVyMiA9IHN0cmVhbTIuZ2V0UmVhZGVyKCk7XG4gIGxldCBsYXN0UmVhZDEgPSB2b2lkIDA7XG4gIGxldCBsYXN0UmVhZDIgPSB2b2lkIDA7XG4gIGxldCBzdHJlYW0xRG9uZSA9IGZhbHNlO1xuICBsZXQgc3RyZWFtMkRvbmUgPSBmYWxzZTtcbiAgYXN5bmMgZnVuY3Rpb24gcmVhZFN0cmVhbTEoY29udHJvbGxlcikge1xuICAgIHRyeSB7XG4gICAgICBpZiAobGFzdFJlYWQxID09IG51bGwpIHtcbiAgICAgICAgbGFzdFJlYWQxID0gcmVhZGVyMS5yZWFkKCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsYXN0UmVhZDE7XG4gICAgICBsYXN0UmVhZDEgPSB2b2lkIDA7XG4gICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShyZXN1bHQudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcmVhZFN0cmVhbTIoY29udHJvbGxlcikge1xuICAgIHRyeSB7XG4gICAgICBpZiAobGFzdFJlYWQyID09IG51bGwpIHtcbiAgICAgICAgbGFzdFJlYWQyID0gcmVhZGVyMi5yZWFkKCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsYXN0UmVhZDI7XG4gICAgICBsYXN0UmVhZDIgPSB2b2lkIDA7XG4gICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShyZXN1bHQudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc3RyZWFtMURvbmUpIHtcbiAgICAgICAgICByZWFkU3RyZWFtMihjb250cm9sbGVyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbTJEb25lKSB7XG4gICAgICAgICAgcmVhZFN0cmVhbTEoY29udHJvbGxlcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UmVhZDEgPT0gbnVsbCkge1xuICAgICAgICAgIGxhc3RSZWFkMSA9IHJlYWRlcjEucmVhZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UmVhZDIgPT0gbnVsbCkge1xuICAgICAgICAgIGxhc3RSZWFkMiA9IHJlYWRlcjIucmVhZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcmVzdWx0LCByZWFkZXIgfSA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgbGFzdFJlYWQxLnRoZW4oKHJlc3VsdDIpID0+ICh7IHJlc3VsdDogcmVzdWx0MiwgcmVhZGVyOiByZWFkZXIxIH0pKSxcbiAgICAgICAgICBsYXN0UmVhZDIudGhlbigocmVzdWx0MikgPT4gKHsgcmVzdWx0OiByZXN1bHQyLCByZWFkZXI6IHJlYWRlcjIgfSkpXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYWRlciA9PT0gcmVhZGVyMSkge1xuICAgICAgICAgIGxhc3RSZWFkMSA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIHJlYWRTdHJlYW0yKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgc3RyZWFtMURvbmUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0UmVhZDIgPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICBzdHJlYW0yRG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZWFkU3RyZWFtMShjb250cm9sbGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2FuY2VsKCkge1xuICAgICAgcmVhZGVyMS5jYW5jZWwoKTtcbiAgICAgIHJlYWRlcjIuY2FuY2VsKCk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3RyZWFtcy9zdHJlYW0tdG8tcmVzcG9uc2UudHNcbmZ1bmN0aW9uIHN0cmVhbVRvUmVzcG9uc2UocmVzLCByZXNwb25zZSwgaW5pdCwgZGF0YSkge1xuICB2YXIgX2E7XG4gIHJlc3BvbnNlLndyaXRlSGVhZCgoX2EgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hIDogMjAwLCB7XG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgLi4uaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzXG4gIH0pO1xuICBsZXQgcHJvY2Vzc2VkU3RyZWFtID0gcmVzO1xuICBpZiAoZGF0YSkge1xuICAgIHByb2Nlc3NlZFN0cmVhbSA9IG1lcmdlU3RyZWFtcyhkYXRhLnN0cmVhbSwgcmVzKTtcbiAgfVxuICBjb25zdCByZWFkZXIgPSBwcm9jZXNzZWRTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgcmVhZGVyLnJlYWQoKS50aGVuKCh7IGRvbmUsIHZhbHVlIH0pID0+IHtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHJlc3BvbnNlLmVuZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNwb25zZS53cml0ZSh2YWx1ZSk7XG4gICAgICByZWFkKCk7XG4gICAgfSk7XG4gIH1cbiAgcmVhZCgpO1xufVxuXG4vLyBzdHJlYW1zL3N0cmVhbWluZy10ZXh0LXJlc3BvbnNlLnRzXG52YXIgU3RyZWFtaW5nVGV4dFJlc3BvbnNlID0gY2xhc3MgZXh0ZW5kcyBSZXNwb25zZSB7XG4gIGNvbnN0cnVjdG9yKHJlcywgaW5pdCwgZGF0YSkge1xuICAgIGxldCBwcm9jZXNzZWRTdHJlYW0gPSByZXM7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHByb2Nlc3NlZFN0cmVhbSA9IG1lcmdlU3RyZWFtcyhkYXRhLnN0cmVhbSwgcmVzKTtcbiAgICB9XG4gICAgc3VwZXIocHJvY2Vzc2VkU3RyZWFtLCB7XG4gICAgICAuLi5pbml0LFxuICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlUmVzcG9uc2VIZWFkZXJzKGluaXQsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzdHJlYW1zL2luZGV4LnRzXG52YXIgZ2VuZXJhdGVJZDIgPSBnZW5lcmF0ZUlkSW1wbDtcbnZhciBuYW5vaWQgPSBnZW5lcmF0ZUlkSW1wbDtcbmV4cG9ydCB7XG4gIEFJU3RyZWFtLFxuICBBUElDYWxsRXJyb3IyIGFzIEFQSUNhbGxFcnJvcixcbiAgQVdTQmVkcm9ja0FudGhyb3BpY01lc3NhZ2VzU3RyZWFtLFxuICBBV1NCZWRyb2NrQW50aHJvcGljU3RyZWFtLFxuICBBV1NCZWRyb2NrQ29oZXJlU3RyZWFtLFxuICBBV1NCZWRyb2NrTGxhbWEyU3RyZWFtLFxuICBBV1NCZWRyb2NrU3RyZWFtLFxuICBBbnRocm9waWNTdHJlYW0sXG4gIEFzc2lzdGFudFJlc3BvbnNlLFxuICBDb2hlcmVTdHJlYW0sXG4gIEVtYmVkTWFueVJlc3VsdCxcbiAgRW1iZWRSZXN1bHQsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEdlbmVyYXRlT2JqZWN0UmVzdWx0LFxuICBHZW5lcmF0ZVRleHRSZXN1bHQsXG4gIEdvb2dsZUdlbmVyYXRpdmVBSVN0cmVhbSxcbiAgSHVnZ2luZ0ZhY2VTdHJlYW0sXG4gIElua2VlcFN0cmVhbSxcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IyIGFzIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcjIgYXMgSW52YWxpZERhdGFDb250ZW50RXJyb3IsXG4gIEludmFsaWRNZXNzYWdlUm9sZUVycm9yLFxuICBJbnZhbGlkTW9kZWxJZEVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IyIGFzIEludmFsaWRQcm9tcHRFcnJvcixcbiAgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yLFxuICBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yMiBhcyBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yLFxuICBKU09OUGFyc2VFcnJvcixcbiAgbGFuZ2NoYWluX2FkYXB0ZXJfZXhwb3J0cyBhcyBMYW5nQ2hhaW5BZGFwdGVyLFxuICBMYW5nQ2hhaW5TdHJlYW0sXG4gIExvYWRBUElLZXlFcnJvcixcbiAgTWlzdHJhbFN0cmVhbSxcbiAgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcjIgYXMgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcixcbiAgTm9TdWNoTW9kZWxFcnJvcixcbiAgTm9TdWNoUHJvdmlkZXJFcnJvcixcbiAgTm9TdWNoVG9vbEVycm9yMyBhcyBOb1N1Y2hUb29sRXJyb3IsXG4gIE9wZW5BSVN0cmVhbSxcbiAgUmVwbGljYXRlU3RyZWFtLFxuICBSZXRyeUVycm9yMiBhcyBSZXRyeUVycm9yLFxuICBTdHJlYW1EYXRhLFxuICBTdHJlYW1PYmplY3RSZXN1bHQsXG4gIFN0cmVhbVRleHRSZXN1bHQsXG4gIFN0cmVhbWluZ1RleHRSZXNwb25zZSxcbiAgVG9vbENhbGxQYXJzZUVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcixcbiAgVW5zdXBwb3J0ZWRKU09OU2NoZW1hRXJyb3IsXG4gIGNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nLFxuICBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXksXG4gIGNvbnZlcnRUb0NvcmVNZXNzYWdlcyxcbiAgY29zaW5lU2ltaWxhcml0eSxcbiAgY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIsXG4gIGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIsXG4gIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcixcbiAgZW1iZWQsXG4gIGVtYmVkTWFueSxcbiAgZXhwZXJpbWVudGFsX0Fzc2lzdGFudFJlc3BvbnNlLFxuICBleHBlcmltZW50YWxfU3RyZWFtRGF0YSxcbiAgZXhwZXJpbWVudGFsX2NyZWF0ZU1vZGVsUmVnaXN0cnksXG4gIGV4cGVyaW1lbnRhbF9jcmVhdGVQcm92aWRlclJlZ2lzdHJ5LFxuICBleHBlcmltZW50YWxfZ2VuZXJhdGVPYmplY3QsXG4gIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZVRleHQsXG4gIGV4cGVyaW1lbnRhbF9zdHJlYW1PYmplY3QsXG4gIGV4cGVyaW1lbnRhbF9zdHJlYW1UZXh0LFxuICBmb3JtYXRTdHJlYW1QYXJ0LFxuICBnZW5lcmF0ZUlkMiBhcyBnZW5lcmF0ZUlkLFxuICBnZW5lcmF0ZU9iamVjdCxcbiAgZ2VuZXJhdGVUZXh0LFxuICBuYW5vaWQsXG4gIHBhcnNlQ29tcGxleFJlc3BvbnNlLFxuICBwYXJzZVN0cmVhbVBhcnQsXG4gIHJlYWREYXRhU3RyZWFtLFxuICByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlLFxuICBzdHJlYW1PYmplY3QsXG4gIHN0cmVhbVRleHQsXG4gIHN0cmVhbVRvUmVzcG9uc2UsXG4gIHRvb2wsXG4gIHRyaW1TdGFydE9mU3RyZWFtSGVscGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/dist/index.mjs\n");

/***/ })

};
;